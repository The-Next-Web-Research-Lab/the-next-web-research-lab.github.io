import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as s,c as a,a as e,b as l,d as t,e as i}from"./app-8e8a04f7.js";const c={},u=i('<h1 id="gof-디자인-패턴-요약" tabindex="-1"><a class="header-anchor" href="#gof-디자인-패턴-요약" aria-hidden="true">#</a> GoF 디자인 패턴 | 요약</h1><blockquote><p>출처: 에릭 감마 , 리처드 헬름 , 랄프 존슨 , 존 블리시디스. 『Gof의 디자인 패턴』. 김정아(역). 프로텍미디어, 2015.</p></blockquote><p>GoF(Gang of Four)는 <strong>Design Patterns: Elements of Reusable Object-Oriented Software</strong>를 집필한 저자 4명을 말한다. 에릭 감마(Erich Gamma), 리차드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시데스(John Vlissides)가 이 책의 저자들이다.</p><p>Design Patterns은 세 가지 카테고리로 분류되어 23개 패턴이 있다. 대부분 예제는 C++로 작성되었고, 일부는 Smalltalk로 작성되었다.</p><h4 id="생성-패턴-creational-pattern" tabindex="-1"><a class="header-anchor" href="#생성-패턴-creational-pattern" aria-hidden="true">#</a> 생성 패턴(Creational Pattern)</h4><p>인스턴스를 만드는 절차를 추상화하는 패턴이다. 객체를 생성 및 합성하는 방법 또는 객체의 표현 방법을 시스템에서 분리해준다.</p>',6),_=e("li",null,[e("strong",null,"추상 팩토리"),l(" : 구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 서로 독립적인 객체들의 집합을 생성할 수 있는 인터페이스를 제공하는 패턴")],-1),h=e("li",null,[e("strong",null,"빌더"),l(" : 복잡한 객체를 생성하는 방법과 표현하는 방법을 정의하는 클래스를 별도로 분리하여, 서로 다른 표현이라도 이를 생성할 수 있는 동일한 절차를 제공할 수 있도록 합니다.")],-1),d=e("li",null,[e("strong",null,"팩토리 메서드"),l(" : 객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 합니다.")],-1),p=e("li",null,[e("strong",null,"원형"),l(" : 원형이 되는 인스턴스를 사용하여 생성할 객체의 종류를 명시하고, 이렇게 만든 견본을 복사해서 새로운 객체를 생성합니다.")],-1),g=e("strong",null,"싱글턴",-1),f={href:"https://angular.io/guide/dependency-injection#injector-hierarchy-and-service-instances",target:"_blank",rel:"noopener noreferrer"},b=e("h4",{id:"구조-패턴-structual-pattern",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#구조-패턴-structual-pattern","aria-hidden":"true"},"#"),l(" 구조 패턴(Structual Pattern)")],-1),m=e("p",null,"더 큰 구조를 형성하기 위해 어떻게 클래스와 객체를 합성하는가와 관련된 패턴입니다.",-1),v=e("li",null,[e("strong",null,"어뎁터"),l(" : 클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 적응시킵니다. 서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작시킵니다.")],-1),k=e("li",null,[e("strong",null,"브릿지"),l(" : 구현에서 추상을 분리하여, 이들이 독립적으로 다양성을 가질 수 있도록 합니다.")],-1),x=e("li",null,[e("strong",null,"컴포지트"),l(" : 부분과 전체의 계층을 표현하기 위해 객체들을 모아 트리 구조로 구성합니다. 사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 하는 패턴입니다.")],-1),S=e("strong",null,"데코레이터",-1),I={href:"https://www.typescriptlang.org/docs/handbook/decorators.html",target:"_blank",rel:"noopener noreferrer"},P=e("li",null,[e("strong",null,"퍼사드"),l(" : 한 서브시스템 내의 인터페이스 집합에 대한 획일화된 하나의 인터페이스를 제공하는 패턴으로, 서브시스템을 사용하기 쉽도록 상위 수준의 인터페이스를 정의합니다.")],-1),y=e("li",null,[e("strong",null,"플라이웨이트"),l(" : 공유를 통해 많은 수의 소립 객체들을 효과적으로 지원한다.")],-1),O=e("strong",null,"프록시",-1),E={href:"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy",target:"_blank",rel:"noopener noreferrer"},G=e("h4",{id:"행동-패턴-behavioral-pattern",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#행동-패턴-behavioral-pattern","aria-hidden":"true"},"#"),l(" 행동 패턴(Behavioral Pattern)")],-1),R=e("p",null,"어떤 처리의 책임을 어느 객체에 할당하는 것이 좋은지, 알고리즘은 어느 객체에 정의하는 것이 좋은지 다룹니다.",-1),V=e("li",null,[e("strong",null,"책임연쇄"),l(" : 메세지를 보내는 객체와 이를 받아 처리하는 객체들 간의 결합도를 없애기 위한 패턴입니다.")],-1),j=e("li",null,[e("strong",null,"명령"),l(" : 요청 자체를 캡슐화하는 것입니다. 이를 통해 요청이 서로 다른 사용자를 매개변수로 만들고, 요청을 대기 시키거나 로깅하여, 되돌릴 수 있는 연산을 지원합니다.")],-1),w=e("li",null,[e("strong",null,"해석자"),l(" : 간단한 언어의 문법을 정의하는 방법과 그 언어로 문장을 구성하는 방법, 이들 문장을 해석하는 방법을 설명합니다.")],-1),z=e("strong",null,"반복자",-1),B={href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols",target:"_blank",rel:"noopener noreferrer"},J=e("li",null,[e("strong",null,"중재자"),l(" : 한 집합에 속해 있는 객체의 상호작용을 캡슐화하는 객체를 정의합니다.")],-1),N=e("li",null,[e("strong",null,"메멘토"),l(" : 캡슐화를 위배하지 않은 체 어떤 객체의 내부 상태를 잡아내고 실체화 시켜둠으로써, 이후 해당 객체가 그 상태로 되돌아 올 수 있도록 합니다.")],-1),W=e("strong",null,"감시자",-1),A={href:"https://developer.mozilla.org/ko/docs/Web/API/MutationObserver",target:"_blank",rel:"noopener noreferrer"},C={href:"https://developer.mozilla.org/ko/docs/Web/API/IntersectionObserver/IntersectionObserver",target:"_blank",rel:"noopener noreferrer"},D=e("li",null,[e("strong",null,"상태"),l(" : 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게끔 허가하는 패턴으로, 이렇게 하면 객체를 마치 자신의 클래스를 바꾸는 것 처럼 보인다.")],-1),F=e("li",null,[e("strong",null,"전략"),l(" : 동일 계열의 알고리즘군을 정의하고, 각각의 알고리즘을 캡슐화하여, 이들을 상호교환이 가능하도록 만드는 패턴이다.")],-1),q=e("li",null,[e("strong",null,"탬플릿 메소드"),l(" : 객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스쪽으로 미루는 패턴이다. 알고리즘의 구조 자체는 그대로 놔둔 채 알고리즘 각 단계의 처리를 서브클래스에서 재정의할 수 있게 한다.")],-1),L=e("li",null,[e("strong",null,"방문자"),l(" : 객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴으로, 연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연산을 정의할 수 있게 한다.")],-1);function M(T,H){const n=r("ExternalLinkIcon");return s(),a("div",null,[u,e("ul",null,[_,h,d,p,e("li",null,[g,l(" : 오직 한 개의 클래스 인스턴스만을 갖도록 보장하고, 이에 대한 전역적인 접근점을 제공합니다. "),e("ul",null,[e("li",null,[e("a",f,[l("Angular Service"),t(n)])])])])]),b,m,e("ul",null,[v,k,x,e("li",null,[S,l(" : 객체에 동적으로 새로운 책임을 추가할 수 있게 합니다. 기능을 추가하려면, 서브클래스를 생성하는 것보다 융통성 있는 방법을 제공합니다. "),e("ul",null,[e("li",null,[e("a",I,[l("TypeScript Decorator"),t(n)])])])]),P,y,e("li",null,[O,l(" : 다른 객체에 대한 접근을 제어하기 위한 대리자 또는 자리체움자 역할을 하는 객체를 둔다. "),e("ul",null,[e("li",null,[e("a",E,[l("ES6 Proxy"),t(n)])])])])]),G,R,e("ul",null,[V,j,w,e("li",null,[z,l(" : 내부 표현부를 노출하지 않고 어떤 집합 객체에 속한 원소들을 순차적으로 접근할 수 있는 방법을 제공합니다. "),e("ul",null,[e("li",null,[e("a",B,[l("ES6 Iterator"),t(n)])])])]),J,N,e("li",null,[W,l(" : 객체 사이에 일대 다의 의존 관계를 정의해두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지 받고 자동으로 갱신될 수 있게 만듭니다. "),e("ul",null,[e("li",null,[e("a",A,[l("MutationObserver"),t(n)])]),e("li",null,[e("a",C,[l("IntersectionObserver"),t(n)])])])]),D,F,q,L])])}const Q=o(c,[["render",M],["__file","summary.html.vue"]]);export{Q as default};
