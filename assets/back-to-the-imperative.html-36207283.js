const t=JSON.parse('{"key":"v-a97a2788","path":"/en/fe-dev/paradigm/back-to-the-imperative.html","title":"Shifting to imperative programming thinking","lang":"en-US","frontmatter":{"title":"Shifting to imperative programming thinking","description":"Shifting to imperative programming thinking Imperative vs. functional Compare two lists by concatenating them Reference: Purely Functional Data Structures, Chris Okasaki Imperative In the imperative method, two lists can be concatenated in O(1) by maintaining pointers to the first and last cells of the list. This can be easily implemented by changing the last cell of the first list to point to the first cell of the second list. Note that it destroys both lists. You cannot reuse two lists after concatenating them.","head":[["link",{"rel":"alternate","hreflang":"ko-kr","href":"https://the-next-web-research-lab.github.io/fe-dev/paradigm/back-to-the-imperative.html"}],["meta",{"property":"og:url","content":"https://the-next-web-research-lab.github.io/en/fe-dev/paradigm/back-to-the-imperative.html"}],["meta",{"property":"og:site_name","content":"TheNextWebResearchLab"}],["meta",{"property":"og:title","content":"Shifting to imperative programming thinking"}],["meta",{"property":"og:description","content":"Shifting to imperative programming thinking Imperative vs. functional Compare two lists by concatenating them Reference: Purely Functional Data Structures, Chris Okasaki Imperative In the imperative method, two lists can be concatenated in O(1) by maintaining pointers to the first and last cells of the list. This can be easily implemented by changing the last cell of the first list to point to the first cell of the second list. Note that it destroys both lists. You cannot reuse two lists after concatenating them."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://the-next-web-research-lab.github.io/images/og_image.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"ko-KR"}],["meta",{"property":"og:updated_time","content":"2024-02-01T14:00:12.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Shifting to imperative programming thinking"}],["meta",{"property":"article:modified_time","content":"2024-02-01T14:00:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Shifting to imperative programming thinking\\",\\"image\\":[\\"https://the-next-web-research-lab.github.io/images/og_image.png\\"],\\"dateModified\\":\\"2024-02-01T14:00:12.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"Imperative vs. functional","slug":"imperative-vs-functional","link":"#imperative-vs-functional","children":[{"level":3,"title":"Compare two lists by concatenating them","slug":"compare-two-lists-by-concatenating-them","link":"#compare-two-lists-by-concatenating-them","children":[]},{"level":3,"title":"Error handling comparison","slug":"error-handling-comparison","link":"#error-handling-comparison","children":[]},{"level":3,"title":"Iterative processing comparison","slug":"iterative-processing-comparison","link":"#iterative-processing-comparison","children":[]}]},{"level":2,"title":"Distinguish between imperative/object-oriented/functional paradigms","slug":"distinguish-between-imperative-object-oriented-functional-paradigms","link":"#distinguish-between-imperative-object-oriented-functional-paradigms","children":[{"level":3,"title":"Imperative","slug":"imperative-2","link":"#imperative-2","children":[]},{"level":3,"title":"Object-oriented","slug":"object-oriented","link":"#object-oriented","children":[]},{"level":3,"title":"Functional","slug":"functional-2","link":"#functional-2","children":[]}]},{"level":2,"title":"end","slug":"end","link":"#end","children":[]}],"git":{"createdTime":1706796012000,"updatedTime":1706796012000,"contributors":[{"name":"ChoDragon9","email":"04whdydrn30@gmail.com","commits":1}]},"readingTime":{"minutes":3.49,"words":1048},"filePathRelative":"en/fe-dev/paradigm/back-to-the-imperative.md","localizedDate":"February 1, 2024","excerpt":"<h1> Shifting to imperative programming thinking</h1>\\n<h2> Imperative vs. functional</h2>\\n<h3> Compare two lists by concatenating them</h3>\\n<blockquote>\\n<p>Reference: Purely Functional Data Structures, Chris Okasaki</p>\\n</blockquote>\\n<h4> Imperative</h4>\\n<p>In the imperative method, two lists can be concatenated in O(1) by maintaining pointers to the first and last cells of the list. This can be easily implemented by changing the last cell of the first list to point to the first cell of the second list. Note that it destroys both lists. You cannot reuse two lists after concatenating them.</p>","autoDesc":true}');export{t as data};
