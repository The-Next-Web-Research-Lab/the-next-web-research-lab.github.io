import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as s,o as i,c as l,a as e,b as r,d as n,e as a}from"./app-69da0665.js";const d={},c=a('<h1 id="옵져버-매커니즘" tabindex="-1"><a class="header-anchor" href="#옵져버-매커니즘" aria-hidden="true">#</a> 옵져버 매커니즘</h1><blockquote><p>2019년 5월 20일에 정리한 포스트입니다.</p></blockquote><h3 id="글의-목적" tabindex="-1"><a class="header-anchor" href="#글의-목적" aria-hidden="true">#</a> 글의 목적</h3><blockquote><p>정보 전달 목적보다는 자료 정리 목적으로 작성된 포스트라 정돈이 안되있다.</p></blockquote><p>AngularJs를 사용한 프로젝트에서 성능 이슈로 밤낮세며 개선 방안을 찾은 기억이 있다. 그 경험 때문에 라이브러리들의 옵져버 매커니즘은 어떻게 구현되는 지 가끔 살펴본다. 개인적으로는 그 중에 VueJs의 옵져버 매커니즘은 가장 이상적이라고 생각한다. 각 라이브러리 별로 구현된 옵져버 매커니즘을 정리해본 자료이다.</p><h3 id="목차" tabindex="-1"><a class="header-anchor" href="#목차" aria-hidden="true">#</a> 목차</h3><ul><li>AngularJs</li><li>Angular</li><li>VueJs</li><li>React</li></ul><h3 id="라이브러리별-옵져버-매커니즘" tabindex="-1"><a class="header-anchor" href="#라이브러리별-옵져버-매커니즘" aria-hidden="true">#</a> 라이브러리별 옵져버 매커니즘</h3><h4 id="angularjs" tabindex="-1"><a class="header-anchor" href="#angularjs" aria-hidden="true">#</a> AngularJs</h4><p>먼저 왜 AngularJs에서 성능 이슈를 발생했는 지 정리했다.</p><p>AngularJs는 <strong>$digest loop</strong>를 통해서 변경 감지를 하는 데, <strong>$digest loop</strong>는 <strong>$watcher</strong>에 등록된 모델의 변경 체크하고 변경 시 <strong>$watcher</strong>에 등록된 이벤트 핸들러를 실행한다.</p><p>만약에 모델의 변경이 됬다면 <strong>$digest loop</strong>를 다시 실행하게 되고 이것을 <strong>Dirty Checking</strong>이라고 불린다. 이 과정에서 성능이슈가 발생하게 되고 모델과 디렉티브를 많이 사용하게 되면 성능이 급격히 감소한다.</p><h4 id="vuejs" tabindex="-1"><a class="header-anchor" href="#vuejs" aria-hidden="true">#</a> VueJs</h4>',13),u={href:"https://kr.vuejs.org/v2/guide/reactivity.html",target:"_blank",rel:"noopener noreferrer"},h=a(`<p><strong>Vue 2.0</strong>에서는 <strong>Object.defineProperty</strong>를 통해서 구현되있다. <strong>data</strong> 옵션으로 전달되는 모든 속성을 <strong>Object.defineProperty</strong>를 통해 변경 감지를 한다. 하지만 <strong>Object.defineProperty</strong>의 한계는 존재한다.</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- ES5 지원 브라우저만 동작
- 속성 추가 감지할 수 없음
- data는 배열로 선언할 수 없음
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),p={href:"https://www.vuemastery.com/courses/advanced-components/build-a-reactivity-system",target:"_blank",rel:"noopener noreferrer"},g=a(`<p><strong>Vue 3.0</strong>에서는 <strong>Proxy</strong>를 통해서 구현되있다.</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- Property addition / deletion
- Array index / length mutation
- Map, Set, WeakMap, WeakSet
- Classes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),b={href:"https://www.youtube.com/watch?v=8Hgt9HYaCDA",target:"_blank",rel:"noopener noreferrer"},_=e("strong",null,"Object.defineProperty",-1),v={href:"https://www.vuemastery.com/courses/advanced-components/evan-you-on-proxies",target:"_blank",rel:"noopener noreferrer"},f=e("h4",{id:"angular",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#angular","aria-hidden":"true"},"#"),r(" Angular")],-1),m={href:"https://github.com/angular/angular/search?l=TypeScript&q=defineProperty&type=",target:"_blank",rel:"noopener noreferrer"},x=e("p",null,[r("Angular부터는 변경 감지를 "),e("strong",null,"Object.defineProperty"),r("를 통해 구현했다. 그리고 RxJs의 Observable는 Vanilla Js로 "),e("strong",null,"Subject와 Observable 패턴"),r("이 구현되있다.")],-1),y=e("h4",{id:"react",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#react","aria-hidden":"true"},"#"),r(" React")],-1),k={href:"https://github.com/facebook/react/search?utf8=%E2%9C%93&q=defineProperty&type=",target:"_blank",rel:"noopener noreferrer"},P=e("p",null,[r("React도 변경감지를 "),e("strong",null,"Object.defineProperty"),r("를 통해 구현했다. 적용 범위는 이벤트, 입력폼, Props 등에 사용되었다.")],-1),V=e("h3",{id:"끝",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#끝","aria-hidden":"true"},"#"),r(" 끝")],-1),j=e("p",null,"Angular와 React는 공식적으로 어떻게 구현되었는 지 자료가 없다. 그래서 Github 코드를 통해서 확인하는 과정으로 작성했다.",-1);function w(A,J){const t=s("ExternalLinkIcon");return i(),l("div",null,[c,e("blockquote",null,[e("p",null,[e("a",u,[r("Vue 2.0 반응형에 대해 깊이 알아보기"),n(t)])])]),h,e("p",null,[r("이러한 단점이 있지만 모든 반응 속성을 미리 선언하여 컴포넌트 상태 스키마로 사용 되기 때문에 코드 유지 관리 측면에서 장점이 있다. 자세한 구현내용은 "),e("a",p,[r("Vue Mastery - Build a Reactivity System"),n(t)]),r(" 에서 확인할 수 있다.")]),g,e("p",null,[e("a",b,[r("Vue 3.0을 소개하는 영상"),n(t)]),r("에서 Evan You는 Proxy-based의 장점을 설명했다. "),_,r("의 단점을 보완이 가능해졌고, 성능도 향상되었다. "),e("a",v,[r("Evan You on Proxies"),n(t)]),r("에서 변경하려는 의지를 보였던 거 같다.")]),f,e("blockquote",null,[e("p",null,[e("a",m,[r("Angular defineProperty"),n(t)]),r(" 검색")])]),x,y,e("blockquote",null,[e("p",null,[e("a",k,[r("React defineProperty"),n(t)]),r(" 검색")])]),P,V,j])}const E=o(d,[["render",w],["__file","observation-mechanism.html.vue"]]);export{E as default};
