import{_ as i,o as l,c as e,e as a}from"./app-73d15a96.js";const d={},n=a(`<h1 id="도서-리뷰-시리즈-http-완벽-가이드" tabindex="-1"><a class="header-anchor" href="#도서-리뷰-시리즈-http-완벽-가이드" aria-hidden="true">#</a> 도서 리뷰 시리즈 - HTTP 완벽 가이드</h1><h2 id="출처" tabindex="-1"><a class="header-anchor" href="#출처" aria-hidden="true">#</a> 출처</h2><p>데이빗 고울리, 브라이언 토티, 마조리 세이어, 세일루 레디, 안슈 아가왈. 『HTTP 완벽 가이드』. 이응준(역), 정상일(역). 인사이트, 2014.</p><h2 id="한-줄-리뷰" tabindex="-1"><a class="header-anchor" href="#한-줄-리뷰" aria-hidden="true">#</a> 한 줄 리뷰</h2><p>HTTP를 알 고 있어도 이 책을 보면 새롭게 보입니다.</p><h2 id="http" tabindex="-1"><a class="header-anchor" href="#http" aria-hidden="true">#</a> HTTP</h2><ul><li>HTTP는 애플리케이션 계층 프로토콜이다.</li><li>TCP/IP을 사용하며, TCP와 IP는 패킷 교환 네트워크 프로토콜의 집합이다. <ul><li>TCP는 IP, Port를 사용해서 컨넥션을 맺는다.</li></ul></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>5. 애플리케이션 계층: HTTP
4. 전송 계층: TCP
3. 네트워크 계층: IP
2. 데이터 링크 계층: 네트워크를 위한 링크 인터페이스
1. 물리 계층: 물리적인 네트워크 하드웨어
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="http-2-0" tabindex="-1"><a class="header-anchor" href="#http-2-0" aria-hidden="true">#</a> HTTP/2.0</h2><ul><li>HTTP의 메시지 교환 방식은 응답을 받아야만 다음 요청을 보낼 수 있기 때문에 심각한 회전 지연(latency)를 피할 수 없다.</li><li>이를 개선하기 위해 HTTP/1.1의 저자 중 한 명인 로이 필딩(Roy Fielding)은 WAKA를, MS에서는 S+M(Speed+Mobility)를, 구글에서는 SPDY를 제안했다.</li><li>HTTP 작업 그룹은 구글의 SPDY를 기반으로 HTTP/2.0 초안을 작성했으며, SPDY의 특징을 거의 그대로 유지하고 있다.</li><li>HTTP/2.0은 서버와 클라이언트 사이의 TCP 컨넥션 위에서 동작한다.</li></ul><h3 id="개선점" tabindex="-1"><a class="header-anchor" href="#개선점" aria-hidden="true">#</a> 개선점</h3><ol><li>스트림 <ul><li>[HTTP/1.1] 요청/응답을 마다 TCP 컨넥션을 맺었다. 여러 개의 TCP 컨넥션 맺어 병렬적으로 요청/응답한다.</li><li>[HTTP/2.0] 하나의 TCP 컨넥션에 여러 개의 스트림을 만들어 요청/응답을 동시에 처리한다. 스트림의 고유 식별자가 고갈되면 TCP 컨넥션을 다시 맺는다.</li></ul></li><li>헤더 압축 <ul><li>[HTTP/1.1] 헤더를 아무런 압축 없이 그대로 전송되었다.</li><li>[HTTP/2.0] HPACK 명세 기반으로 헤더 압축하여 전송한다.</li></ul></li><li>서버 푸시 <ul><li>서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 해준다.</li></ul></li></ol><h2 id="https" tabindex="-1"><a class="header-anchor" href="#https" aria-hidden="true">#</a> HTTPS</h2><p>HTTPS를 사용할 때, 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화된다. HTTPS는 HTTP의 하부에 전송 레벨 암호 보안 계층을 제공함으로 동작한다. 이 보안 계층은 전송 계층 보안(Transport Layer Security, TLS)을 이용하여 구현된다.</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>6. 애플리케이션 계층: HTTP
5. 보안 계층: TLS
4. 전송 계층: TCP
3. 네트워크 계층: IP
2. 데이터 링크 계층: 네트워크를 위한 링크 인터페이스
1. 물리 계층: 물리적인 네트워크 하드웨어
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>인코딩 및 디코딩 작업은 대부분 보안 계층에서 이뤄지기 때문에 웹 클라이언트나 서버에서 로직을 수정할 필요는 없다.</p><h3 id="트랜잭션" tabindex="-1"><a class="header-anchor" href="#트랜잭션" aria-hidden="true">#</a> 트랜잭션</h3><ul><li>HTTP <ol><li>서버의 80 포트로 TCP 컨넥션 수립</li><li>TCP를 통해 보내진 HTTP 요청</li><li>TCP를 통해 보내진 HTTP 응답</li><li>TCP 컨넥션 닫힘</li></ol></li><li>HTTPS <ol><li>서버의 443 포트로 TCP 컨넥션 수립</li><li>SSL 보안 매개변수 핸드셰이크</li><li>SSL을 통해 보내진 HTTP 요청/TCP를 통해 보내진 암호화된 요청</li><li>SSL을 통해 보내진 HTTP 응답/TCP를 통해 보내진 암호화된 응답</li><li>SSL 닫힘 통지</li><li>TCP 컨넥션 닫힘</li></ol></li></ul><h3 id="ssl-핸드셰이크" tabindex="-1"><a class="header-anchor" href="#ssl-핸드셰이크" aria-hidden="true">#</a> SSL 핸드셰이크</h3><ol><li>클라이언트가 암호 후보들을 보내고 인증서를 요구한다.</li><li>서버는 선택된 암호와 인증서를 보낸다.</li><li>클라이언트가 비밀정보를 보낸다. 클라이언트와 서버는 키를 만든다.</li><li>클라이언트와 서버는 서로에게 암호화를 시작한다고 말해준다.</li></ol>`,20),r=[n];function s(t,T){return l(),e("div",null,r)}const c=i(d,[["render",s],["__file","7.html.vue"]]);export{c as default};
