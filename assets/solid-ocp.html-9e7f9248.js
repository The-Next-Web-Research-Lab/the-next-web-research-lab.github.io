import{_ as e,o,c,e as a}from"./app-630d2f93.js";const p={},t=a('<h1 id="solid-원칙-시리즈-개방-패쇄-원칙" tabindex="-1"><a class="header-anchor" href="#solid-원칙-시리즈-개방-패쇄-원칙" aria-hidden="true">#</a> SOLID 원칙 시리즈 - 개방-패쇄 원칙</h1><h2 id="ocp-개방-패쇄-원칙-open-closed-principle" tabindex="-1"><a class="header-anchor" href="#ocp-개방-패쇄-원칙-open-closed-principle" aria-hidden="true">#</a> OCP: 개방-패쇄 원칙 (Open-Closed Principle)</h2><p>개방 폐쇄 원칙은 &quot;소프트웨어 개체(artifact)는 확장에는 열려 있어야 하고, 변경에는 닫혀있어야 한다.&quot;를 의미한다.</p><p>다시 말해 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 산출물을 변경해서는 안 된다.</p><p>소프트웨어 아키텍처를 공부하는 가장 근본적인 이유가 바로 이 때문이다. 만약 요구사항을 살짝 확장하는 데 수정사항이 많다면 설계한 아키텍트는 엄청난 실패에 맞닥뜨린 것이다.</p><p>소프트웨어 아키텍처가 훌륭하다면 변경되는 코드의 양이 가능한 한 최소화될 것이다. 이상적인 변경량은 0이다. 어떻게 하면 될까? 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고(단일 책임 원칙, SRP), 이들 요소 사이의 의존성을 체계화함으로써(의존성 역전 원칙, DIP) 변경량을 최소화할 수 있다.</p><p>아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다. 컴포넌트 계층구조를 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.</p><p>OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다. 이러한 목표를 달성하려면 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생하는 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층 구조가 만들어 지도록 해야 한다.</p>',8),i=[t];function r(n,s){return o(),c("div",null,i)}const l=e(p,[["render",r],["__file","solid-ocp.html.vue"]]);export{l as default};
