import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o,c as t,e as i}from"./app-8f51c971.js";const s={},c=i('<h1 id="solid-원칙-시리즈-리스코프-치환-원칙" tabindex="-1"><a class="header-anchor" href="#solid-원칙-시리즈-리스코프-치환-원칙" aria-hidden="true">#</a> SOLID 원칙 시리즈 - 리스코프 치환 원칙</h1><h2 id="lsp-리스코프-치환-원칙-liskov-substitution-principle" tabindex="-1"><a class="header-anchor" href="#lsp-리스코프-치환-원칙-liskov-substitution-principle" aria-hidden="true">#</a> LSP: 리스코프 치환 원칙 (Liskov Substitution Principle)</h2><p>리스코프 치환 원칙는 바바라 리스코프가 정의한 원칙으로 바바라 리스코드는 하위 타입을 다음과 같이 정의했다.</p><blockquote><p>여기에서 필요한 것은 다음과 같은 치환(substitution) 원칙이다. S타입의 객체 <code>o1</code> 각각에 대응하는 T타입 객체 <code>o2</code>가 있고, T타입을 이용해서 정의한 모든 프로그램 P에 <code>o2</code>의 자리에 <code>o1</code>을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위타입이다.</p></blockquote><p>LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다. 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.</p>',5),d=[c];function a(r,n){return o(),t("div",null,d)}const h=e(s,[["render",a],["__file","solid-lsp.html.vue"]]);export{h as default};
