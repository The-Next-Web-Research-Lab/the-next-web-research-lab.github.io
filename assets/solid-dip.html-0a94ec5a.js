import{_ as e,o as i,c as n,e as a}from"./app-f227ea51.js";const r={},d=a('<h1 id="solid-원칙-시리즈-의존성-역전-원칙" tabindex="-1"><a class="header-anchor" href="#solid-원칙-시리즈-의존성-역전-원칙" aria-hidden="true">#</a> SOLID 원칙 시리즈 - 의존성 역전 원칙</h1><h2 id="dip-의존성-역전-원칙-dependency-inversion-principle" tabindex="-1"><a class="header-anchor" href="#dip-의존성-역전-원칙-dependency-inversion-principle" aria-hidden="true">#</a> DIP: 의존성 역전 원칙 (Dependency Inversion Principle)</h2><p>의존성 역전 원칙에서 말하는 유연성이 극대화된 시스템이란 소스 코드 의존성이 추상에 의존하여 구체에는 의존하지 않는 시스템이다.</p><p>이 아이디어를 규칙으로 보기는 확실히 비현실적이다. 소프트웨어 시스템이라면 구체적인 많은 장치에 반드시 의존하기 때문이다. DIP를 논할 때 운영체제나 플랫폼같이 안전성이 보장된 환경에 대해서는 무시하는 편이다.</p><p>우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰 구체적인 요소이다. 그리고 이 구체적인 요소는 우리가 열심히 개발하는 중이라 자주 변경될 수밖에 없는 모듈들이다.</p><p>인터페이스는 구현체보다 변동성이 낮다. 그래서 실제로 뛰어난 소프트웨어 설계자와 아키텍트라면 인터페이스의 변동성을 낮추기 위해 애쓴다. 인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 방법을 찾기 위해 노력한다. 이는 소프트웨어 설계의 기본이다.</p><p><strong>안정된 소프트웨어 아키텍처</strong>란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻이다.</p><h4 id="구체적인-코딩-실천법" tabindex="-1"><a class="header-anchor" href="#구체적인-코딩-실천법" aria-hidden="true">#</a> 구체적인 코딩 실천법</h4><ul><li>변동성이 큰 구체 클래스를 참조하지 마라 <ul><li>추상 인터페이스를 사용하라</li><li>객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리를 사용하도록 강제하라</li></ul></li><li>구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 마라</li></ul>',9),l=[d];function c(s,o){return i(),n("div",null,l)}const p=e(r,[["render",c],["__file","solid-dip.html.vue"]]);export{p as default};
