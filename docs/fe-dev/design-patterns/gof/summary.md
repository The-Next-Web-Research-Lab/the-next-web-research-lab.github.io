---
title: GoF 디자인 패턴 | 요약
---

# GoF 디자인 패턴 | 요약

> 출처: 에릭 감마 , 리처드 헬름 , 랄프 존슨 , 존 블리시디스. 『Gof의 디자인 패턴』. 김정아(역). 프로텍미디어, 2015.

GoF(Gang of Four)는 **Design Patterns: Elements of Reusable Object-Oriented Software**를 집필한 저자 4명을 말한다.
에릭 감마(Erich Gamma), 리차드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시데스(John Vlissides)가 이 책의 저자들이다.

Design Patterns은 세 가지 카테고리로 분류되어 23개 패턴이 있다. 대부분 예제는 C++로 작성되었고, 일부는 Smalltalk로 작성되었다. 

#### 생성 패턴(Creational Pattern)
인스턴스를 만드는 절차를 추상화하는 패턴이다.
객체를 생성 및 합성하는 방법 또는 객체의 표현 방법을 시스템에서 분리해준다.

- **추상 팩토리** : 구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 서로 독립적인 객체들의 집합을 생성할 수 있는 인터페이스를 제공하는 패턴
- **빌더** : 복잡한 객체를 생성하는 방법과 표현하는 방법을 정의하는 클래스를 별도로 분리하여, 서로 다른 표현이라도 이를 생성할 수 있는 동일한 절차를 제공할 수 있도록 합니다.
- **팩토리 메서드** : 객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 합니다.
- **원형** : 원형이 되는 인스턴스를 사용하여 생성할 객체의 종류를 명시하고, 이렇게 만든 견본을 복사해서 새로운 객체를 생성합니다.
- **싱글턴** : 오직 한 개의 클래스 인스턴스만을 갖도록 보장하고, 이에 대한 전역적인 접근점을 제공합니다.
  - [Angular Service](https://angular.io/guide/dependency-injection#injector-hierarchy-and-service-instances)

#### 구조 패턴(Structual Pattern)
더 큰 구조를 형성하기 위해 어떻게 클래스와 객체를 합성하는가와 관련된 패턴입니다.

- **어뎁터** : 클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 적응시킵니다. 서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작시킵니다.
- **브릿지** : 구현에서 추상을 분리하여, 이들이 독립적으로 다양성을 가질 수 있도록 합니다.
- **컴포지트** : 부분과 전체의 계층을 표현하기 위해 객체들을 모아 트리 구조로 구성합니다. 사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 하는 패턴입니다.
- **데코레이터** : 객체에 동적으로 새로운 책임을 추가할 수 있게 합니다. 기능을 추가하려면, 서브클래스를 생성하는 것보다 융통성 있는 방법을 제공합니다.
  - [TypeScript Decorator](https://www.typescriptlang.org/docs/handbook/decorators.html)
- **퍼사드** : 한 서브시스템 내의 인터페이스 집합에 대한 획일화된 하나의 인터페이스를 제공하는 패턴으로, 서브시스템을 사용하기 쉽도록 상위 수준의 인터페이스를 정의합니다.
- **플라이웨이트** : 공유를 통해 많은 수의 소립 객체들을 효과적으로 지원한다.
- **프록시** : 다른 객체에 대한 접근을 제어하기 위한 대리자 또는 자리체움자 역할을 하는 객체를 둔다.
  - [ES6 Proxy](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy)

#### 행동 패턴(Behavioral Pattern)
어떤 처리의 책임을 어느 객체에 할당하는 것이 좋은지, 알고리즘은 어느 객체에 정의하는 것이 좋은지 다룹니다.

- **책임연쇄** : 메세지를 보내는 객체와 이를 받아 처리하는 객체들 간의 결합도를 없애기 위한 패턴입니다.
- **명령** : 요청 자체를 캡슐화하는 것입니다. 이를 통해 요청이 서로 다른 사용자를 매개변수로 만들고, 요청을 대기 시키거나 로깅하여, 되돌릴 수 있는 연산을 지원합니다.
- **해석자** : 간단한 언어의 문법을 정의하는 방법과 그 언어로 문장을 구정하는 방법, 이들 문장을 해석하는 방법을 설명합니다.
- **반복자** : 내부 표현부를 노출하지 않고 어떤 집합 객체에 속한 원소들을 순차적으로 접근할 수 있는 방법을 제공합니다.
  - [ES6 Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)
- **중재자** : 한 집합에 속해 있는 객체의 상호작용을 캡슐화하는 객체를 정의합니다.
- **메멘토** : 캡슐화를 위배하지 않은 체 어떤 객체의 내부 상태를 잡아내고 실체화 시켜둠으로써, 이후 해당 객체가 그 상태로 되돌아 올 수 있도록 합니다.
- **감시자** : 객체 사이에 일대 다의 의존 관계를 정의해두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지 받고 자동으로 갱신될 수 있게 만듭니다.
  - [MutationObserver](https://developer.mozilla.org/ko/docs/Web/API/MutationObserver)
  - [IntersectionObserver](https://developer.mozilla.org/ko/docs/Web/API/IntersectionObserver/IntersectionObserver)
- **상태** : 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게끔 허가하는 패턴으로, 이렇게 하면 객체를 마치 자신의 클래스를 바꾸는 것 처럼 보인다.
- **전략** : 동일 계열의 알고리즘군을 정의하고, 각각의 알고리즘을 캡슐화하여, 이들을 상호교환이 가능하도록 만드는 패턴이다.
- **탬플릿 메소드** : 객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스쪽으로 미루는 패턴이다. 알고리즘의 구조 자체는 그대로 놔둔 채 알고리즘 각 단계의 처리를 서브클래스에서 재정의할 수 있게 한다.
- **방문자** : 객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴으로, 연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연산을 정의할 수 있게 한다.
