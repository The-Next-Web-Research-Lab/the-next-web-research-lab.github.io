export const data = JSON.parse("{\"key\":\"v-4d1ec4d0\",\"path\":\"/fe-dev/paradigm/back-to-the-imperative.html\",\"title\":\"명령형 프로그래밍 사고로 전환하기\",\"lang\":\"ko-KR\",\"frontmatter\":{\"title\":\"명령형 프로그래밍 사고로 전환하기\",\"description\":\"명령형 프로그래밍 사고로 전환하기 명령형과 함수형 비교 두 리스트 연결로 비교 순수 함수형 데이터 구조 도서 명령형 명령형 방식에서는 리스트의 첫 셀과 마지막 셀에 대한 포인터를 유지함으로써 O(1)만에 두 리스트를 이어 붙일 수 있다. 첫 번째 리스트의 마지막 셀이 두 번째 리스트의 첫 번째 셀을 가리키도록 변경함으로써 쉽게 구현할 수 있다. 단 두 리스트를 모두 파괴한다는 점에 유의해야 한다. 두 리스트를 이어 붙인 뒤 두 리스트를 재사용할 수 없다.\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://the-next-web-research-lab.github.io/fe-dev/paradigm/back-to-the-imperative.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"더넥스트웹리서치랩\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"명령형 프로그래밍 사고로 전환하기\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"명령형 프로그래밍 사고로 전환하기 명령형과 함수형 비교 두 리스트 연결로 비교 순수 함수형 데이터 구조 도서 명령형 명령형 방식에서는 리스트의 첫 셀과 마지막 셀에 대한 포인터를 유지함으로써 O(1)만에 두 리스트를 이어 붙일 수 있다. 첫 번째 리스트의 마지막 셀이 두 번째 리스트의 첫 번째 셀을 가리키도록 변경함으로써 쉽게 구현할 수 있다. 단 두 리스트를 모두 파괴한다는 점에 유의해야 한다. 두 리스트를 이어 붙인 뒤 두 리스트를 재사용할 수 없다.\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:image\",\"content\":\"https://the-next-web-research-lab.github.io/images/og_image.png\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"ko-KR\"}],[\"meta\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"meta\",{\"name\":\"twitter:image:alt\",\"content\":\"명령형 프로그래밍 사고로 전환하기\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"명령형 프로그래밍 사고로 전환하기\\\",\\\"image\\\":[\\\"https://the-next-web-research-lab.github.io/images/og_image.png\\\"],\\\"dateModified\\\":null,\\\"author\\\":[]}\"]]},\"headers\":[{\"level\":2,\"title\":\"명령형과 함수형 비교\",\"slug\":\"명령형과-함수형-비교\",\"link\":\"#명령형과-함수형-비교\",\"children\":[{\"level\":3,\"title\":\"두 리스트 연결로 비교\",\"slug\":\"두-리스트-연결로-비교\",\"link\":\"#두-리스트-연결로-비교\",\"children\":[]},{\"level\":3,\"title\":\"에러 처리 비교\",\"slug\":\"에러-처리-비교\",\"link\":\"#에러-처리-비교\",\"children\":[]},{\"level\":3,\"title\":\"반복 처리 비교\",\"slug\":\"반복-처리-비교\",\"link\":\"#반복-처리-비교\",\"children\":[]}]},{\"level\":2,\"title\":\"명령형/객체지향/함수형 패러다임 구분하기\",\"slug\":\"명령형-객체지향-함수형-패러다임-구분하기\",\"link\":\"#명령형-객체지향-함수형-패러다임-구분하기\",\"children\":[{\"level\":3,\"title\":\"명령형\",\"slug\":\"명령형-2\",\"link\":\"#명령형-2\",\"children\":[]},{\"level\":3,\"title\":\"객체지향\",\"slug\":\"객체지향\",\"link\":\"#객체지향\",\"children\":[]},{\"level\":3,\"title\":\"함수형\",\"slug\":\"함수형-2\",\"link\":\"#함수형-2\",\"children\":[]}]},{\"level\":2,\"title\":\"끝\",\"slug\":\"끝\",\"link\":\"#끝\",\"children\":[]}],\"readingTime\":{\"minutes\":1.32,\"words\":396},\"filePathRelative\":\"fe-dev/paradigm/back-to-the-imperative.md\",\"excerpt\":\"<h1> 명령형 프로그래밍 사고로 전환하기</h1>\\n<h2> 명령형과 함수형 비교</h2>\\n<h3> 두 리스트 연결로 비교</h3>\\n<blockquote>\\n<p>순수 함수형 데이터 구조 도서</p>\\n</blockquote>\\n<h4> 명령형</h4>\\n<p>명령형 방식에서는 리스트의 첫 셀과 마지막 셀에 대한 포인터를 유지함으로써 O(1)만에 두 리스트를 이어 붙일 수 있다. 첫 번째 리스트의 마지막 셀이 두 번째 리스트의 첫 번째 셀을 가리키도록 변경함으로써 쉽게 구현할 수 있다. 단 두 리스트를 모두 파괴한다는 점에 유의해야 한다. 두 리스트를 이어 붙인 뒤 두 리스트를 재사용할 수 없다.</p>\",\"autoDesc\":true}")

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
