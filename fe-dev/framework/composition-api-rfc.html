<!doctype html>
<html lang="ko-KR" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.66" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://the-next-web-research-lab.github.io/fe-dev/framework/composition-api-rfc.html"><meta property="og:site_name" content="더넥스트웹리서치랩"><meta property="og:title" content="Composition API RFC 번역"><meta property="og:description" content="Composition API RFC 번역 초안작성일: 2020.02.28 경고 Composition API 학습을 위해 Composition API RFC을 번역한 포스트입니다. 공식 문서가 아님을 밝힙니다."><meta property="og:type" content="article"><meta property="og:image" content="https://the-next-web-research-lab.github.io/images/og_image.png"><meta property="og:locale" content="ko-KR"><meta property="og:updated_time" content="2023-06-21T12:02:21.000Z"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="Composition API RFC 번역"><meta property="article:modified_time" content="2023-06-21T12:02:21.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Composition API RFC 번역","image":["https://the-next-web-research-lab.github.io/images/og_image.png"],"dateModified":"2023-06-21T12:02:21.000Z","author":[]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2063927113913779" crossorigin="anonymous"></script><link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.7/dist/web/static/pretendard.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/images/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><meta name="google-site-verification" content="AQgb7qIvzY8UNdV_dzzcCI1ofNUSeJeBRgf-IAajJO0"><meta name="naver-site-verification" content="0adacb2ebffbc3afc4a8525d472fe9ff6029850b"><meta name="google-adsense-account" content="ca-pub-2063927113913779"><title>Composition API RFC 번역 | 더넥스트웹리서치랩</title><meta name="description" content="Composition API RFC 번역 초안작성일: 2020.02.28 경고 Composition API 학습을 위해 Composition API RFC을 번역한 포스트입니다. 공식 문서가 아님을 밝힙니다.">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-4453ef8f.css" as="style"><link rel="stylesheet" href="/assets/style-4453ef8f.css">
    <link rel="modulepreload" href="/assets/app-296313bb.js"><link rel="modulepreload" href="/assets/composition-api-rfc.html-b9b982af.js"><link rel="modulepreload" href="/assets/composition-api-rfc.html-1695f705.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-c27b6911.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">본문으로 건너뛰기</a><!--]--><!--[--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand" href="/"><!----><!----><span class="vp-site-name">더넥스트웹리서치랩</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a class="vp-link nav-link" href="/intro.html"><!---->소개<!----></a></div><div class="nav-item hide-in-mobile"><a class="vp-link nav-link" href="/next-web-research.html"><!---->선행개발<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="실용주의 프런트엔드"><span class="title"><!---->실용주의 프런트엔드</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="vp-link nav-link" href="/fe-dev/self-management.html"><!---->자기 관리<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/fe-dev/javascript.html"><!---->프로그래밍 언어<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/fe-dev/good-code.html"><!---->좋은코드<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/fe-dev/refactoring.html"><!---->리팩터링<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/fe-dev/project-management.html"><!---->프로젝트 관리<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/fe-dev/framework.html"><!---->React / Vue / Angular<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/fe-dev/paradigm.html"><!---->명령형 / 객체지향 / 함수형<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/fe-dev/code-snippets.html"><!---->코드 스니펫<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/fe-dev/pet-project.html"><!---->펫 프로젝트<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/fe-dev/design-patterns.html"><!---->디자인 패턴<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/fe-dev/optimization.html"><!---->성능 최적화<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/fe-dev/books.html"><!---->도서 리뷰<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/fe-dev/interview-guide.html"><!---->면접관 가이드<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a class="vp-link nav-link" href="/essay.html"><!---->경험정리<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="패밀리 사이트"><span class="title"><!---->패밀리 사이트</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="https://www.instagram.com/thenext_webresearchlab/" rel="noopener noreferrer" target="_blank" aria-label="인스타그램" class="nav-link"><!---->인스타그램<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></li><li class="dropdown-item"><a href="https://blog.naver.com/nextwebresearchlab" rel="noopener noreferrer" target="_blank" aria-label="네이버 블로그" class="nav-link"><!---->네이버 블로그<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></li><li class="dropdown-item"><a href="https://the-next-web-research-lab.tistory.com/" rel="noopener noreferrer" target="_blank" aria-label="티스토리 블로그" class="nav-link"><!---->티스토리 블로그<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></li></ul></button></div></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><div class="nav-item"><div class="dropdown-wrapper i18n-dropdown"><button type="button" class="dropdown-title" aria-label="언어 선택"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon i18n-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="i18n icon" style="width:1rem;height:1rem;vertical-align:middle;"><path d="M379.392 460.8 494.08 575.488l-42.496 102.4L307.2 532.48 138.24 701.44l-71.68-72.704L234.496 460.8l-45.056-45.056c-27.136-27.136-51.2-66.56-66.56-108.544h112.64c7.68 14.336 16.896 27.136 26.112 35.84l45.568 46.08 45.056-45.056C382.976 312.32 409.6 247.808 409.6 204.8H0V102.4h256V0h102.4v102.4h256v102.4H512c0 70.144-37.888 161.28-87.04 210.944L378.88 460.8zM576 870.4 512 1024H409.6l256-614.4H768l256 614.4H921.6l-64-153.6H576zM618.496 768h196.608L716.8 532.48 618.496 768z"></path></svg><!--]--><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="vp-link nav-link active" href="/fe-dev/framework/composition-api-rfc.html"><!---->한국어<!----></a></li><li class="dropdown-item"><a class="vp-link nav-link" href="/en/"><!---->English<!----></a></li></ul></button></div></div><!----><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><div id="docsearch-container" style="display:none;"></div><div><button type="button" class="DocSearch DocSearch-Button" aria-label=""><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder"></span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"><svg width="15" height="15" class="DocSearch-Control-Key-Icon"><path d="M4.505 4.496h2M5.505 5.496v5M8.216 4.496l.055 5.993M10 7.5c.333.333.5.667.5 1v2M12.326 4.5v5.996M8.384 4.496c1.674 0 2.116 0 2.116 1.5s-.442 1.5-2.116 1.5M3.205 9.303c-.09.448-.277 1.21-1.241 1.203C1 10.5.5 9.513.5 8V7c0-1.57.5-2.5 1.464-2.494.964.006 1.134.598 1.24 1.342M12.553 10.5h1.953" stroke-width="1.2" stroke="currentColor" fill="none" stroke-linecap="square"></path></svg></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/fe-dev/framework.html"><!---->React / Vue / Angular<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading active"><!----><span class="vp-sidebar-title">Vue Composition API</span><!----></p><ul class="vp-sidebar-links"><li><!--[--><a class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active" href="/fe-dev/framework/composition-api-rfc.html"><!---->Composition API RFC 번역<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#요약"><!---->요약<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#기초-예제"><!---->기초 예제<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#동기-부여"><!---->동기 부여<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#로직-재사용-코드-구성"><!---->로직 재사용 &amp; 코드 구성<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#더-좋은-타입-추론"><!---->더 좋은 타입 추론<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#상세-설계"><!---->상세 설계<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#api-소개"><!---->API 소개<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#코드-구성"><!---->코드 구성<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#논리-추출-및-재사용"><!---->논리 추출 및 재사용<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#기존-api와-함께-사용"><!---->기존 API와 함께 사용<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#플러그인-개발"><!---->플러그인 개발<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#문제점"><!---->문제점<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#refs-도입의-오버헤드"><!---->Refs 도입의 오버헤드<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#ref-vs-reactive"><!---->Ref vs. Reactive<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#반환문의-정확성"><!---->반환문의 정확성<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#유연성이-높을수록-더-많은-훈련이-필요합니다"><!---->유연성이 높을수록 더 많은 훈련이 필요합니다<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#적용-전략"><!---->적용 전략<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#부록"><!---->부록<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#클래스-api의-타입-이슈"><!---->클래스 API의 타입 이슈<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#react-hooks과-비교"><!---->React Hooks과 비교<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a class="vp-link nav-link vp-sidebar-link vp-heading" href="/fe-dev/framework/composition-api-rfc.html#svelte와-비교"><!---->Svelte와 비교<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/fe-dev/framework/composition-api-rfc-summary.html"><!---->Composition API RFC 요약 및 자료 정리<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/fe-dev/framework/composition-api-rfc-release-notes.html"><!---->Composition API RFC 릴리즈 노트 정리<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/fe-dev/framework/composition-api-rfc-migration.html"><!---->Composition API 경험 정리<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/fe-dev/framework/vuex-in-composition-api.html"><!---->Vuex 적용 경험 정리<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading"><!----><span class="vp-sidebar-title">Vue</span><!----></p><ul class="vp-sidebar-links"><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/fe-dev/framework/vue-eslint.html"><!---->Vue ESLint 설정<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/fe-dev/framework/nuxt-2-11-typescript.html"><!---->Nuxt v2.11 기반 nuxt/typescript 환경 세팅<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/fe-dev/framework/nuxt-ts.html"><!---->2019.08.11 Nuxt에서 TypeScript로 개발하기<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/fe-dev/framework/nuxt-migration.html"><!---->2020.02.10 Nuxt v2.0에서 v2.11로 마이그레이션<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading"><!----><span class="vp-sidebar-title">Angular</span><!----></p><ul class="vp-sidebar-links"><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/fe-dev/framework/rxjs-codereview.html"><!---->2019.07.14 RxJs 코드리뷰 사례<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/fe-dev/framework/angular.html"><!---->2019.07.21 Angular의 강력함과 아쉬운점<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><p class="vp-sidebar-heading"><!----><span class="vp-sidebar-title">React</span><!----></p><ul class="vp-sidebar-links"><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/fe-dev/framework/react-convention-for-codereview.html"><!---->2019.11.29 코드리뷰를 위한 React 컨벤션<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->Composition API RFC 번역</h1><div class="page-info"><!----><!----><span class="page-date-info" aria-label="작성일📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-06-21T12:02:21.000Z"></span><!----><span class="page-reading-time-info" aria-label="읽는 시간⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>약 5 분</span><meta property="timeRequired" content="PT5M"></span><!----><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">이 페이지에서<button type="button" class="print-button" title="인쇄"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#요약">요약</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#기초-예제">기초 예제</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#동기-부여">동기 부여</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#로직-재사용-코드-구성">로직 재사용 &amp; 코드 구성</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#더-좋은-타입-추론">더 좋은 타입 추론</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#상세-설계">상세 설계</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#api-소개">API 소개</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#코드-구성">코드 구성</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#논리-추출-및-재사용">논리 추출 및 재사용</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#기존-api와-함께-사용">기존 API와 함께 사용</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#플러그인-개발">플러그인 개발</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#문제점">문제점</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#refs-도입의-오버헤드">Refs 도입의 오버헤드</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#ref-vs-reactive">Ref vs. Reactive</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#반환문의-정확성">반환문의 정확성</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#유연성이-높을수록-더-많은-훈련이-필요합니다">유연성이 높을수록 더 많은 훈련이 필요합니다</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#적용-전략">적용 전략</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2" href="/#부록">부록</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#클래스-api의-타입-이슈">클래스 API의 타입 이슈</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#react-hooks과-비교">React Hooks과 비교</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3" href="/#svelte와-비교">Svelte와 비교</a></li><!----><!--]--></ul></li><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><h1 id="composition-api-rfc-번역" tabindex="-1"><a class="header-anchor" href="#composition-api-rfc-번역" aria-hidden="true">#</a> Composition API RFC 번역</h1><blockquote><p>초안작성일: 2020.02.28</p></blockquote><div class="hint-container warning"><p class="hint-container-title">경고</p><p>Composition API 학습을 위해 <a href="https://vue-composition-api-rfc.netlify.com/" target="_blank" rel="noopener noreferrer">Composition API RFC<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>을 번역한 포스트입니다. 공식 문서가 아님을 밝힙니다.</p></div><div class="hint-container tip"><p class="hint-container-title">팁</p><p>RFC(Request for Comments) 문서는 비평을 기다리는 문서라는 의미로, 컴퓨터 네트워크 공학 등에서 인터넷 기술에 적용 가능한 새로운 연구, 혁신, 기법 등을 아우르는 메모를 나타낸다.</p><ul><li>출처: <a href="https://ko.wikipedia.org/wiki/RFC" target="_blank" rel="noopener noreferrer">위키백과:RFC<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul></div><ul><li>참고 이슈: <a href="https://github.com/vuejs/rfcs/pull/42" target="_blank" rel="noopener noreferrer">#42<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul><h2 id="요약" tabindex="-1"><a class="header-anchor" href="#요약" aria-hidden="true">#</a> 요약</h2><p>컴포지션 API 소개: 컴포넌트 로직을 유연하게 구성할 수 있는 부가적인 함수기반 API 세트입니다.</p><h2 id="기초-예제" tabindex="-1"><a class="header-anchor" href="#기초-예제" aria-hidden="true">#</a> 기초 예제</h2><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>increment<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    Count is: {{ state.count }}, double is: {{ state.double }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> computed <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
      <span class="token literal-property property">double</span><span class="token operator">:</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>count<span class="token operator">++</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">,</span>
      increment
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="동기-부여" tabindex="-1"><a class="header-anchor" href="#동기-부여" aria-hidden="true">#</a> 동기 부여</h2><h3 id="로직-재사용-코드-구성" tabindex="-1"><a class="header-anchor" href="#로직-재사용-코드-구성" aria-hidden="true">#</a> 로직 재사용 &amp; 코드 구성</h3><p>우리 모두가 Vue가 매우 쉽게 픽업하고 중소 규모의 응용 프로그램을 쉽게 구축하는 방법을 좋아합니다. 그러나 오늘날 Vue의 채택이 증가함에 따라 많은 사용자가 Vue를 사용하여 여러 개발자 팀이 오랜 기간 동안 반복하고 유지 관리하는 대규모 프로젝트를 구축하고 있습니다. 수년에 걸쳐 우리는 이러한 프로젝트 중 일부가 Vue의 현재 API에 수반되는 프로그래밍 모델의 한계에 부딪히는 것을 목격했습니다. 문제는 두 가지 범주로 요약할 수 있습니다.</p><ol><li>복잡한 컴포넌트의 코드는 시간이 지남에 따라 기능이 증가함에 따라 추론하기 더 어려워집니다. 이것은 특히 개발자가 스스로 작성하지 않은 코드를 읽을 때 경우에 발생합니다. 근본 원인은 Vue의 기존 API가 옵션별로 코드 구성을 강요하지만 경우에 따라 논리적 문제로 코드를 구성하는 것이 더 합리적입니다.</li><li>여러 컴포넌트간에 논리를 추출하고 재사용하기 위한 깨끗하고 비용이 들지 않는 메커니즘이 없습니다. (<a href="#%EB%85%BC%EB%A6%AC-%EC%B6%94%EC%B6%9C-%EB%B0%8F-%EC%9E%AC%EC%82%AC%EC%9A%A9">논리 추출 및 재사용</a>에 대한 자세한 내용)</li></ol><p>이 RFC에서 제안된 API는 컴포넌트 코드를 구성할 때 사용자에게 더 많은 유연성을 제공합니다. 코드는 항상 옵션별로 코드를 구성하는 대신 특정 기능을 처리하는 함수로 구성 할 수 있습니다. 또한 API는 컴포넌트 간에 또는 심지어 외부 컴포넌트 사이의 논리를 추출하고 재사용하는 것이 더 간단합니다. <a href="#%EC%83%81%EC%84%B8-%EC%84%A4%EA%B3%84">상세 설계</a> 섹션에서 이러한 목표를 달성하는 방법을 보여 드리겠습니다.</p><h3 id="더-좋은-타입-추론" tabindex="-1"><a class="header-anchor" href="#더-좋은-타입-추론" aria-hidden="true">#</a> 더 좋은 타입 추론</h3><p>대규모 프로젝트를 수행하는 개발자의 또 다른 일반적인 기능 요청은 더 나은 TypeScript 지원입니다. Vue의 현재 API는 TypeScript와의 통합과 관련하여 Vue의 속성을 노출하기 위해 단일 <code>this</code> 컨텍스트에 의존하고 Vue 컴포넌트에서 <code>this</code> 를 사용하는 것이 약간 더 많기 때문에 몇 가지 문제를 제기했습니다. 일반 JavaScript 보다 마술적입니다. (예: <code>methods</code> 아래에 중첩된 함수의 <code>this</code> 는 <code>methods</code> 오브젝트가 아닌 컴포넌트 인스턴스를 가리 킵니다). 즉, Vue의 기존 API는 단순히 타입 추론를 염두에 두고 설계되지 않았으며 TypeScript와 잘 작동하도록 만들 때 많은 복잡성을 만듭니다.</p><p>오늘날 Vue를 TypeScript와 함께 사용하는 대부분의 사용자는 데코레이터의 도움을 받아 컴포넌트를 TypeScript 클래스로 제작할 수 있는 라이브러리인 <code>vue-class-component</code> 를 사용하고 있습니다. 3.0을 설계하는 동안 <a href="https://github.com/vuejs/rfcs/pull/17" target="_blank" rel="noopener noreferrer">이전 (드롭된) RFC<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>에서 입력 문제를 보다 효과적으로 해결하기 위해 내장 클래스 API를 제공하려고 시도했습니다. 그러나 설계에 대해 논의하고 반복하면서 클래스 API가 타이핑 문제를 해결하려면 데코레이터에 의존해야 한다는 것을 알았습니다. 이는 구현 세부 사항에 대해 많은 불확실성이 있는 매우 불안정한 2단계 제안입니다. 이것은 기반을 세우는 데 다소 위험한 토대가 됩니다. (클래스 API 타입 문제에 대한 자세한 내용은 <a href="#%ED%81%B4%EB%9E%98%EC%8A%A4-api%EC%9D%98-%ED%83%80%EC%9E%85-%EC%9D%B4%EC%8A%88">여기</a>)</p><p>이에 비해서, 이 RFC에서 제안 된 API는 대부분 자연스럽게 친숙한 일반 변수와 함수를 사용합니다. 제안 된 API로 작성된 코드는 메뉴얼 타입 힌트가 거의 필요없는 완전한 타입 추론을 즐길 수 있습니다. 이는 제안 된 API로 작성된 코드가 TypeScript와 일반 JavaScript에서 거의 동일하게 보일 것이므로 TypeScript가 아닌 사용자도 더 나은 IDE 지원을 위해 타이핑을 활용할 수 있다는 것을 의미합니다.</p><h2 id="상세-설계" tabindex="-1"><a class="header-anchor" href="#상세-설계" aria-hidden="true">#</a> 상세 설계</h2><h3 id="api-소개" tabindex="-1"><a class="header-anchor" href="#api-소개" aria-hidden="true">#</a> API 소개</h3><p>여기에서 제안되는 API는 새로운 개념을 도입하는 대신 반응 상태 생성 및 관찰과 같은 Vue의 핵심 기능을 독립형 함수로 노출하는 것에 관한 것입니다. 여기서는 가장 기본적인 API를 소개하고 컴포넌트 로직을 표현하기 위해 2.x 옵션 대신 사용하는 방법을 소개합니다. 이 섹션은 기본 아이디어를 소개하는 데 중점을 두므로 각 API에 대한 자세한 내용은 다루지 않습니다. 전체 API 사용은 <a href="https://vue-composition-api-rfc.netlify.com/api" target="_blank" rel="noopener noreferrer">API Reference<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 섹션에서 확인할 수 있습니다.</p><h4 id="반응형-상태와-부수효과" tabindex="-1"><a class="header-anchor" href="#반응형-상태와-부수효과" aria-hidden="true">#</a> 반응형 상태와 부수효과</h4><p>간단한 작업부터 시작하겠습니다: 일부 반응 상태 선언.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token comment">// reactive state</span>
<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>reactive</code> 는 2.x의 현재 <code>Vue.observable()</code> API와 동일하며 RxJS Observables과 혼동되지 않도록 이름을 변경되었습니다. 여기서 반환된 상태는 모든 Vue 사용자에게 친숙해야 하는 반응형 객체입니다.</p><p>Vue에서 반응형 상태의 필수 사용 사례는 렌더링 중에 사용할 수 있다는 것입니다. 종속성 추적 덕분에 반응형 사태가 변경 될 때 뷰가 자동으로 업데이트됩니다. DOM에서 무언가를 렌더링하는 것은 &quot;부수효과&quot;로 간주됩니다: 우리의 프로그램은 프로그램 자체(DOM) 외부의 상태를 수정하고 있습니다. 반응형 상태에 따라 부수효과를 적용하고 자동으로 다시 적용하려면 <code>watchEffect</code> API를 사용할 수 있습니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> watchEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">count is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>state<span class="token punctuation">.</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>watchEffect</code> 는 원하는 부수효과를 적용하는 함수를 기대합니다 (이 경우 <code>innerHTML</code> 설정). 함수를 즉시 실행하고 실행 중에 사용한 모든 반응 상태 속성을 종속성으로 추적합니다. 여기서 <code>state.count</code> 는 초기 실행 후이 감시자에 대한 종속성으로 추적됩니다. 앞으로 <code>state.count</code> 가 변경되면 내부 함수가 다시 실행됩니다.</p><p>이것이 Vue의 반응형 시스템의 핵심입니다. 컴포넌트의 <code>data()</code>에서 객체를 반환하면 내부적으로 <code>reactive()</code>에 의해 반응이 이루어집니다. 템플릿은 이러한 반응형 속성을 사용하는 렌더링 함수 (보다 효율적인 <code>innerHTML</code>로 생각)로 컴파일 됩니다.</p><blockquote><p><code>watchEffect</code> 는 2.x <code>watch</code> 옵션과 유사하지만 감시된 데이터 소스와 부수효과 콜백을 분리할 필요가 없습니다. Composition API는 2.x 옵션과 정확히 동일한 동작을 하는 <code>watch</code> 기능을 제공합니다.</p></blockquote><p>위의 예제를 계속하면 사용자 입력을 처리하는 방법입니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  state<span class="token punctuation">.</span>count<span class="token operator">++</span>
<span class="token punctuation">}</span>

document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> increment<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>그러나 Vue의 템플릿 시스템을 사용하면 <code>innerHTML</code> 이나 수동으로 이벤트 리스너를 연결할 필요가 없습니다. 가상의 <code>renderTemplate</code> 메소드를 사용하여 예제를 단순화하여 반응성 측면에 집중할 수 있습니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> watchEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  state<span class="token punctuation">.</span>count<span class="token operator">++</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> renderContext <span class="token operator">=</span> <span class="token punctuation">{</span>
  state<span class="token punctuation">,</span>
  increment
<span class="token punctuation">}</span>

<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// hypothetical internal code, NOT actual API</span>
  <span class="token function">renderTemplate</span><span class="token punctuation">(</span>
    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;button @click=&quot;increment&quot;&gt;{{ state.count }}&lt;/button&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
    renderContext
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="계산된-상태와-refs" tabindex="-1"><a class="header-anchor" href="#계산된-상태와-refs" aria-hidden="true">#</a> 계산된 상태와 Refs</h4><p>때때로 우리는 다른 상태에 의존하는 상태가 필요합니다. Vue에서는 <em>계산된 속성</em> 으로 처리 됩니다. 계산된 값을 직접 생성하기 위해 <code>computed</code> API를 사용할 수 있습니다 :</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> computed <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> double <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>computed</code> 란 무엇입니까? 내부에서 <code>computed</code> 이 어떻게 구현되는 지 추측하면 다음과 같은 결과가 나올 수 있습니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 단순화된 의사 코드</span>
<span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token parameter">getter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> value
  <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    value <span class="token operator">=</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> value
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>그러나 우리는 이것이 작동하지 않는다는 것을 압니다: 만약 <code>value</code> 가 <code>number</code> 와 같은 프리미티브 타입이라면, <code>computed</code> 내부의 업데이트 로직에 대한 연결은 반환되면 손실 될 것입니다. 이는 JavaScript 프리미티브 타입이 참조가 아닌 값으로 전달되기 때문입니다.</p><p>값이 객체에 속성으로 할당 될 때도 같은 문제가 발생합니다. 반응형 값은 속성으로 할당되거나 함수에서 반환 될 때 반응성을 유지할 수 없는 경우가 그다지 유용하지 않습니다. 항상 최신 계산값을 읽을 수 있게 하려면 실제 값을 객체에 래핑하고 대신 해당 객체를 반환해야 합니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 단순화된 의사 코드</span>
<span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token parameter">getter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    ref<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> ref
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>또한 의존성 추적 및 변경 알림을 수행하기 위해 객체의 <code>.value</code> 속성에 대한 읽기/쓰기 작업을 가로 챌 필요가 있습니다 (간단하게 하기 위해 코드를 생략). 이제 반응성 손실에 대한 걱정없이 계산된 값을 참조로 전달할 수 있습니다. 단점은 최신값을 검색하기 위해 이제 <code>.value</code> 를 통해 값을 접근해야 한다는 것입니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> double <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>

<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>double<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// -&gt; 0</span>

state<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token comment">// -&gt; 2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>여기에서 double은 보유하고 있는 내부값에 대한 반응성 참조로 사용되므로 &quot;ref&quot;라고 하는 객체입니다.</p><blockquote><p>Vue에는 이미 &quot;refs&quot;라는 개념이 있지만 템플릿에서 DOM 요소 또는 컴포넌트 인스턴스를 참조하는 경우에만 해당됩니다 (&quot;template refs&quot;). <a href="https://vue-composition-api-rfc.netlify.com/api.html#template-refs" target="_blank" rel="noopener noreferrer">여기<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>에서 새로운 refs 시스템이 논리적인 상태 및 템플릿 refs에 어떻게 사용 될 수 있는 지 확인하십시오.</p></blockquote><p>계산된 refs외에, <code>ref</code> API를 사용하여 일반 가변 참조를 직접 만들 수도 있습니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 0</span>

count<span class="token punctuation">.</span>value<span class="token operator">++</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="참조-언래핑" tabindex="-1"><a class="header-anchor" href="#참조-언래핑" aria-hidden="true">#</a> 참조 언래핑</h4><p>렌더 컨텍스트에서 ref를 속성으로 노출 할 수 있습니다. 내부적으로 Vue는 렌더 컨텍스트에서 ref가 발생할 때 컨텍스트가 내부값을 직접 노출하도록 ref에 대해 특별한 처리를 수행합니다. 이는 템플릿에서 <code>count.value</code> 대신 <code>count</code> 를 직접 쓸 수 있음을 의미합니다.</p><p>다음은 <code>reactive</code> 대신 <code>ref</code> 를 사용하는 동일한 카운터 예제의 버전입니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> watch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  count<span class="token punctuation">.</span>value<span class="token operator">++</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> renderContext <span class="token operator">=</span> <span class="token punctuation">{</span>
  count<span class="token punctuation">,</span>
  increment
<span class="token punctuation">}</span>

<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">renderTemplate</span><span class="token punctuation">(</span>
    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;button @click=&quot;increment&quot;&gt;{{ count }}&lt;/button&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
    renderContext
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>또한 참조가 반응 객체 아래에 속성으로 중첩되면 접근 시 자동으로 래핑되지 않습니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token literal-property property">double</span><span class="token operator">:</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// `state.double.value` 를 사용할 필요가 없습니다.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>double<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="컴포넌트-내에서-사용방법" tabindex="-1"><a class="header-anchor" href="#컴포넌트-내에서-사용방법" aria-hidden="true">#</a> 컴포넌트 내에서 사용방법</h4><p>우리 코드는 이미 사용자 입력에 따라 업데이트 할 수 있는 작동하는 UI를 제공하지만 코드는 한번만 실행되며 재사용 할 수 없습니다. 논리를 재사용하려면 합리적인 다음 단계로 논리를 함수로 리팩토링 하는 것입니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> computed<span class="token punctuation">,</span> watchEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">function</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token literal-property property">double</span><span class="token operator">:</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    state<span class="token punctuation">.</span>count<span class="token operator">++</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    state<span class="token punctuation">,</span>
    increment
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> renderContext <span class="token operator">=</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">renderTemplate</span><span class="token punctuation">(</span>
    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;button @click=&quot;increment&quot;&gt;
      Count is: {{ state.count }}, double is: {{ state.double }}
    &lt;/button&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
    renderContext
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>위의 코드가 컴포넌트 인스턴스의 존재에 의존하지 않는 방법에 유의하십시오. 실제로 지금까지 소개된 API는 모두 컴포넌트의 컨텍스트 외부에서 사용할 수 있으므로 보다 다양한 시나리오에서 Vue의 반응성 시스템을 활용할 수 있습니다.</p></blockquote><p>이제 <code>setup()</code> 호출, 감시자 생성 및 템플릿을 프레임워크로 렌더링 하는 작업을 마치면 <code>setup()</code> 함수와 템플릿만으로 컴포넌트를 정의 할 수 있습니다.</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>increment<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    Count is: {{ state.count }}, double is: {{ state.double }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> computed <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
      <span class="token literal-property property">double</span><span class="token operator">:</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>count<span class="token operator">++</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">,</span>
      increment
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>이것은 우리가 잘 알고 있는 단일 파일 컴포넌트 형식이며 논리 형식(<code>&lt;script&gt;</code>) 만 다른 형식으로 표현됩니다. 템플릿 구문은 그대로 유지됩니다. <code>&lt;script&gt;</code> 은 생략되었지만 정확히 동일하게 작동합니다.</p><h4 id="라이프사이클-훅" tabindex="-1"><a class="header-anchor" href="#라이프사이클-훅" aria-hidden="true">#</a> 라이프사이클 훅</h4><p>지금까지 컴포넌트의 순수한 상태 측면인 사용자 상태의 반응 상태, 계산된 상태 및 변경 상태에 대해 살펴 보았습니다. 그러나 컴포넌트는 부수효과를 수행해야 할 수도 있습니다 (예: 콘솔 로깅, ajax 요청 전송 또는 <code>window</code> 에서 이벤트 리스너 설정). 이러한 부수효과는 일반적으로 다음 타이밍에 수행됩니다.</p><ul><li>상태가 변할 때</li><li>컴포넌트가 마운트, 업데이트 또는 마운트 해제 될 때(라이프사이클 훅)</li></ul><p>우리는 <code>watchEffect</code> 와 <code>watch</code> API를 사용하여 상태 변화에 따라 부수효과를 적용할 수 있다는 것을 알고 있습니다. 서로 다른 라이브사이클 훅에서 부수효과를 수행하기 위해 전용 <code>onXXX</code> API(기존 라이프사이클 옵션을 직접 미러링)를 사용할 수 있습니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> onMounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;component is mounted!&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>이러한 라이프사이클 등록 방법은 <code>setup</code> 훅을 호출하는 동안에만 사용할 수 있습니다. 내부 전역 상태를 사용하여 <code>setup</code> 훅을 호출하는 현재 인스턴스를 자동으로 알아냅니다. 이 기능은 의도적으로 논리를 외부 기능으로 추출 할 때 마찰을 줄이도록 설계되었습니다.</p><blockquote><p>이러한 API에 대한 자세한 내용은 <a href="https://vue-composition-api-rfc.netlify.com/api" target="_blank" rel="noopener noreferrer">API Reference<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 에서 확인할 수 있습니다. 그러나 설계 세부 사항을 파기 전에 다음 섹션을 마무리하는 것이 좋습니다.</p></blockquote><h3 id="코드-구성" tabindex="-1"><a class="header-anchor" href="#코드-구성" aria-hidden="true">#</a> 코드 구성</h3><p>이 시점에서 가져온 함수로 컴포넌트 API를 복제했습니다. 옵션으로 컴포넌트를 정의하는 것은 큰 기능으로 모든 것을 함께 혼합하는 것보다 훨씬 더 체계적으로 보입니다!</p><p>이해할 수 있는 첫인상입니다. 그러나 동기 부여 섹션에서 언급한 것처럼 Composition API는 실제로 복잡한 컴포넌트에서 보다 체계적인 코드를 생성 할 수 있다고 생각합니다. 여기서 우리는 이유를 설명하려고 노력할 것입니다.</p><h4 id="조직화된-코드-란-무엇입니까" tabindex="-1"><a class="header-anchor" href="#조직화된-코드-란-무엇입니까" aria-hidden="true">#</a> &quot;조직화된 코드&quot;란 무엇입니까?</h4><p>한 걸음 물러서서 &quot;조직화된 코드&quot;에 대해 이야기 할 때 실제로 무엇을 의미하는 지 생각해 봅시다. 코드를 체계적으로 유지하는 최종 목표는 코드를 보다 쉽게 읽고 이해하도록 하는 것입니다. 그리고 코드를 &quot;이해&quot;한다는 것은 무엇을 의미합니까? 컴포넌트에 포함된 옵션을 알고 있기 때문에 컴포넌트를 &quot;이해&quot;한다고 실제로 말할 수 있습니까? 다른 개발자가 작성한 큰 컴포넌트를 본 적이 있습니까? (예를 들어 <a href="https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L198-L404" target="_blank" rel="noopener noreferrer">이것<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>) 그리고 머리를 감싸매고 힘든 시간을 보내고 있습니까?</p><p>위의 링크와 같은 큰 컴포넌트를 통해 동료 개발자를 어떻게 도울 수 있을지 생각해보십시오. &quot;이 컴포넌트는 이러한 데이터 속성, 계산된 속성 및 방법을 가지고 있습니다&quot; 대신 &quot;이 컴포넌트는 X, Y 및 Z를 처리합니다&quot;로 시작할 것입니다. 컴포넌트를 이해하는 데 있어 &quot;컴포넌트가 사용하는 옵션&quot;보다는 &quot;컴포넌트가 수행하려는 작업&quot; (즉, 코드의 의도)에 더 관심이 있습니다. 옵션 기반 API로 작성된 코드는 후자에 자연스럽게 응답하지만 전자를 표현하는 데 다소 열악한 작업을 수행합니다.</p><h4 id="논리적-문제-vs-옵션-타입" tabindex="-1"><a class="header-anchor" href="#논리적-문제-vs-옵션-타입" aria-hidden="true">#</a> 논리적 문제 vs. 옵션 타입</h4><p>컴포넌트가 처리하는 &quot;논리적 문제&quot;로 &quot;X, Y 및 Z&quot;를 정의해 봅시다. 전체 컴포넌트가 하나의 논리적 문제를 다루기 때문에 가독성 문제는 일반적으로 작은 단일 목적 컴포넌트에는 존재하지 않습니다. 그러나 고급 사용 사례에서는 이 문제가 훨씬 두드러집니다. 예로서 <a href="https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L198-L404" target="_blank" rel="noopener noreferrer">Vue CLI UI file explorer<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 를 사용하십시오. 컴포넌트는 여러 가지 논리적 문제를 처리해야 합니다.</p><ul><li>현재 폴더 상태 추적 및 내용 표시</li><li>폴더 탐색 처리 (열기, 닫기, 새로 고침)</li><li>새 폴더 생성 처리</li><li>즐겨 찾기 폴더만 표시 전환</li><li>숨김 폴더 표시 전환</li><li>현재 작업 디렉토리 변경 처리</li></ul><p>옵션 기반 코드를 읽음으로써 이러한 논리적 문제를 즉시 인식하고 구분할 수 있습니까? 확실히 어렵습니다. 특정 논리적 문제와 관련된 코드가 종종 조각 나고 흩어져 있음을 알 수 있습니다. 예를 들어 &quot;새 폴더 만들기&quot; 기능은 <a href="https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L221-L222" target="_blank" rel="noopener noreferrer">두 데이터 속성<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>, <a href="https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L240" target="_blank" rel="noopener noreferrer">하나의 계산된 속성<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 및 <a href="https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L387" target="_blank" rel="noopener noreferrer">메소드<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> - 메소드는 데이터 속성에서 100 줄 이상 떨어진 위치에 정의됩니다.</p><p>이러한 논리적 문제를 각각 색상으로 구분하면 컴포넌트 옵션으로 표현할 때 조각화가 어떻게 발생하는지 알 수 있습니다.</p><p>이러한 단편화는 복잡한 컴포넌트를 이해하고 유지하기 어렵게 만듭니다. 옵션을 통해 강제 분리는 근본적인 논리적 문제를 모호하게 합니다. 또한 하나의 논리적 문제에 대해 작업 할 때 해당 문제와 관련된 부분을 찾기 위해 옵션 블록 주위를 지속적으로 &quot;점프&quot;해야 합니다.</p><blockquote><p>참고: 원래 코드는 몇 군데 개선 될 수 있지만 실제로 작성한 실제 코드의 예를 제공하기 위해 수정없이 최신 커밋을 보여줍니다(이 글을 쓰는 시점에서).</p></blockquote><p>동일한 논리적 문제와 관련된 코드를 함께 배치할 수 있다면 훨씬 더 좋을 것입니다. 이것이 바로 Composition API가 할 수 있는 일입니다. &quot;새 폴더 만들기&quot; 기능은 다음과 같이 작성할 수 있습니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">useCreateFolder</span> <span class="token punctuation">(</span><span class="token parameter">openFolder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 원래 데이터 속성</span>
  <span class="token keyword">const</span> showNewFolder <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> newFolderName <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">)</span>

  <span class="token comment">// 원래 계산된 속성</span>
  <span class="token keyword">const</span> newFolderValid <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">isValidMultiName</span><span class="token punctuation">(</span>newFolderName<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token comment">// 원래 메소드</span>
  <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">createFolder</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newFolderValid<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">mutate</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">mutation</span><span class="token operator">:</span> <span class="token constant">FOLDER_CREATE</span><span class="token punctuation">,</span>
      <span class="token literal-property property">variables</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">name</span><span class="token operator">:</span> newFolderName<span class="token punctuation">.</span>value
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token function">openFolder</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>data<span class="token punctuation">.</span>folderCreate<span class="token punctuation">.</span>path<span class="token punctuation">)</span>
    newFolderName<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">&#39;&#39;</span>
    showNewFolder<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    showNewFolder<span class="token punctuation">,</span>
    newFolderName<span class="token punctuation">,</span>
    newFolderValid<span class="token punctuation">,</span>
    createFolder
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>새 폴더 만들기 기능과 관련된 모든 논리가 이제 단일 기능으로 배치되고 캡슐화되는 방법에 주목하십시오. 이 기능은 설명적인 이름으로 인해 자체 문서화되어 있습니다. 이것을 <strong>컴포지션 함수</strong> 라고합니다. <code>use</code> 로 함수 이름을 시작하여 컴포지션 함수임을 나타내는 것이 권장되는 규칙입니다. 이 패턴은 컴포넌트의 다른 모든 논리적 문제에 적용될 수 있으며 여러 가지 기능이 분리되어 있습니다.</p><blockquote><p>이 비교에는 import 문과 <code>setup()</code> 함수는 제외됩니다. Composition API를 사용하여 다시 구현 된 전체 컴포넌트는 <a href="https://gist.github.com/yyx990803/8854f8f6a97631576c14b63c8acd8f2e" target="_blank" rel="noopener noreferrer">여기<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>에서 찾을 수 있습니다.</p></blockquote><p>각 논리적 문제에 대한 코드는 이제 컴포지션 함수로 함께 배치됩니다. 따라서 큰 컴포넌트를 다룰 때 일정한 &quot;점프&quot;가 필요하지 않습니다. 컴포지션 함수를 편집기에서 접어 컴포넌트를 훨씬 쉽게 스캔할 수 있습니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">useCurrentFolderData</span><span class="token punctuation">(</span><span class="token parameter">networkState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">useFolderNavigation</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> networkState<span class="token punctuation">,</span> currentFolderData <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">useFavoriteFolder</span><span class="token punctuation">(</span><span class="token parameter">currentFolderData</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">useHiddenFolders</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">useCreateFolder</span><span class="token punctuation">(</span><span class="token parameter">openFolder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>setup()</code> 함수는 이제 모든 컴포지션 함수가 호출되는 진입점 역할을 합니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Network</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> networkState <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useNetworkState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// Folder</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> folders<span class="token punctuation">,</span> currentFolderData <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useCurrentFolderData</span><span class="token punctuation">(</span>networkState<span class="token punctuation">)</span>
    <span class="token keyword">const</span> folderNavigation <span class="token operator">=</span> <span class="token function">useFolderNavigation</span><span class="token punctuation">(</span><span class="token punctuation">{</span> networkState<span class="token punctuation">,</span> currentFolderData <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> favoriteFolders<span class="token punctuation">,</span> toggleFavorite <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useFavoriteFolders</span><span class="token punctuation">(</span>currentFolderData<span class="token punctuation">)</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> showHiddenFolders <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useHiddenFolders</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> createFolder <span class="token operator">=</span> <span class="token function">useCreateFolder</span><span class="token punctuation">(</span>folderNavigation<span class="token punctuation">.</span>openFolder<span class="token punctuation">)</span>

    <span class="token comment">// Current working directory</span>
    <span class="token function">resetCwdOnLeave</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> updateOnCwdChanged <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useCwdUtils</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// Utils</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> slicePath <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">usePathUtils</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      networkState<span class="token punctuation">,</span>
      folders<span class="token punctuation">,</span>
      currentFolderData<span class="token punctuation">,</span>
      folderNavigation<span class="token punctuation">,</span>
      favoriteFolders<span class="token punctuation">,</span>
      toggleFavorite<span class="token punctuation">,</span>
      showHiddenFolders<span class="token punctuation">,</span>
      createFolder<span class="token punctuation">,</span>
      updateOnCwdChanged<span class="token punctuation">,</span>
      slicePath
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>물론, 이것은 옵션 API를 사용할 때 작성할 필요가 없는 코드입니다. 그러나 <code>setup()</code> 함수가 컴포넌트가 무엇을 하려고 하는지에 대한 구두 설명과 거의 같은 방식으로 읽습니다. 이것은 옵션 기반 버전에서 완전히 누락된 정보입니다. 또한 전달되는 인수를 기반으로 컴포지션 함수간의 종속성 흐름을 명확하게 볼 수 있습니다. 마지막으로 반환문은 템플릿에 노출된 내용을 확인하는 단일 장소 역할을 합니다.</p><p>동일한 기능이 주어지면 옵션을 통해 정의된 컴포넌트와 컴포지션 함수를 통해 정의된 컴포넌트는 동일한 기본 논리를 표현하는 두 가지 다른 방법을 나타냅니다. 옵션 기반 API를 사용하면 <em>옵션 타입</em> 을 기반으로 코드를 구성해야하지만 Composition API를 사용하면 <em>논리적 문제</em> 를 기반으로 코드를 구성할 수 있습니다.</p><h3 id="논리-추출-및-재사용" tabindex="-1"><a class="header-anchor" href="#논리-추출-및-재사용" aria-hidden="true">#</a> 논리 추출 및 재사용</h3><p>Composition API는 컴포넌트에서 로직을 추출하고 재사용할 때 매우 유연합니다. 컴포지션 함수는 마법의 <code>this</code> 컨텍스트에 의존하는 대신 인수와 전 세계적으로 가져온 Vue API에만 의존합니다. 단순히 컴포넌트 로직을 함수로 내보내서 컴포넌트 로직의 일부를 재사용할 수 있습니다. 컴포넌트의 전체 <code>setup</code> 함수를 내보내서 <code>extends</code> 와 동일한 기능을 수행할 수도 있습니다.</p><p>예를 살펴 보겠습니다: 마우스 위치 추적.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> onMounted<span class="token punctuation">,</span> onUnmounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> y <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

  <span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">.</span>value <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX
    y<span class="token punctuation">.</span>value <span class="token operator">=</span> e<span class="token punctuation">.</span>pageY
  <span class="token punctuation">}</span>

  <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;mousemove&#39;</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token function">onUnmounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    window<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;mousemove&#39;</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>다음은 컴포넌트가 함수를 사용하는 방법입니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useMousePosition <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./mouse&#39;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// other logic...</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>파일 탐색기 예제의 Composition API 버전에서는 일부 유틸리티 코드(예: <code>usePathUtils</code> 및 <code>useCwdUtils</code>)를 다른 컴포넌트에 유용하기 때문에 외부 파일로 추출했습니다.</p><p>믹스인, 고차 컴포넌트 또는 렌더리스 컴포넌트(스코프 슬롯을 통한)와 같은 기본 패턴을 사용하여 유사한 로직 재사용을 달성 할 수도 있습니다. 인터넷에는 이러한 패턴을 설명하는 많은 정보가 있으므로 여기에서 자세한 설명하지는 않겠습니다. 높은 수준의 아이디어는 이러한 각 패턴이 컴포지션 함수와 비교할 때 각각의 단점이 있다는 것입니다.</p><ul><li>렌더링 컨텍스트에 노출된 속성의 소스가 명확하지 않습니다. 예를 들어 여러 믹스인을 사용하여 컴포넌트의 템플릿을 읽을 때 특정 속성을 주입한 믹스인을 구분하기가 어려울 수 있습니다.</li><li>네임 스페이스 충돌. 믹스인은 속성 및 메서드 이름과 충돌할 가능성이 있는 반면 HOC는 prop 이름과 충돌 할 수 있습니다.</li><li>성능. HOC 및 렌더리스 컴포넌트에는 성능 비용이 드는 추가 상태 저장 컴포넌트 인스턴스가 필요합니다.</li></ul><p>Composition API와 비교하면 다음과 같습니다.</p><ul><li>템플릿에 노출된 속성은 컴포지션 함수에서 반환된 값이므로 명확한 소스를 갖습니다.</li><li>컴포지션 함수에서 반환된 값의 이름을 임의로 지정할 수 있으므로 네임 스페이스 충돌이 없습니다.</li><li>로직 재사용을 위해 생성된 불필요한 컴포넌트 인스턴스가 없습니다.</li></ul><h3 id="기존-api와-함께-사용" tabindex="-1"><a class="header-anchor" href="#기존-api와-함께-사용" aria-hidden="true">#</a> 기존 API와 함께 사용</h3><p>Composition API는 기존 옵션 기반 API와 함께 사용할 수 있습니다.</p><ul><li>Composition API는 2.x 옵션 (<code>data</code>, <code>computed</code> &amp; <code>methods</code>) 이전에 해결되었으며 해당 옵션으로 정의된 속성에 접근할 수 없습니다.</li><li><code>setup()</code> 에서 반환된 속성은 <code>this</code>에 노출되며 2.x 옵션 내에서 접근할 수 있습니다.</li></ul><h3 id="플러그인-개발" tabindex="-1"><a class="header-anchor" href="#플러그인-개발" aria-hidden="true">#</a> 플러그인 개발</h3><p>오늘날 많은 Vue 플러그인은 <code>this</code> 에 속성을 주입합니다. 예를 들어 Vue Router는 <code>this.$route</code>와 <code>this.$router</code> 를 주입하고 Vuex는 <code>this.$store</code>를 주입합니다. 각 플러그인은 사용자가 주입된 속성에 대한 Vue 타이핑을 강화해야 하기 때문에 타입 추론이 까다로워졌습니다.</p><p>Composition API를 사용할 때는 <code>this</code> 가 없습니다. 대신 플러그인 내부적으로 <a href="https://vue-composition-api-rfc.netlify.com/api.html#provide-inject" target="_blank" rel="noopener noreferrer"><code>provide</code>와 <code>inject</code><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 를 활용하고 컴포지션 함수를 노출합니다. 다음은 플러그인에 대한 가상 코드입니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> StoreSymbol <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">provideStore</span><span class="token punctuation">(</span><span class="token parameter">store</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">provide</span><span class="token punctuation">(</span>StoreSymbol<span class="token punctuation">,</span> store<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">inject</span><span class="token punctuation">(</span>StoreSymbol<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>store<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// throw error, no store provided</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> store
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>그리고 코드를 소비 할 때:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// provide store at component root</span>
<span class="token comment">//</span>
<span class="token keyword">const</span> App <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">provideStore</span><span class="token punctuation">(</span>store<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> Child <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">useStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// use the store</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0009-global-api-change.md#provide--inject" target="_blank" rel="noopener noreferrer">Global API change RFC<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>에 제안된 앱 레벨 제공을 통해 스토어를 제공할 수도 있습니다. 그러나 사용측 컴포넌트의 <code>useStore</code> 스타일 API는 동일합니다.</p><h2 id="문제점" tabindex="-1"><a class="header-anchor" href="#문제점" aria-hidden="true">#</a> 문제점</h2><h3 id="refs-도입의-오버헤드" tabindex="-1"><a class="header-anchor" href="#refs-도입의-오버헤드" aria-hidden="true">#</a> Refs 도입의 오버헤드</h3><p>Ref는 기술적으로 이 제안에서 소개된 유일한 새로운 개념입니다. <code>this</code>에 대한 엑세스에 의존하지 않고 반응값을 변수로 전달하기 위해 도입되었습니다. 단점은:</p><ol><li>컴포지션 API를 사용할 때, API와 작업 할 때 정신적 부담을 증가 시켜서 참조값과 일반값 및 객체를 지속적으로 구분해야 합니다. <br><br> 명명 규칙(예: 모든 참조 변수의 접미사를 <code>xxxRef</code>로 사용)을 사용하거나 타입 시스템을 사용하면 정신적 부담을 크게 줄일 수 있습니다. 반면에, 코드 구성의 유연성이 향상되기 때문에 컴포넌트 로직이 로컬 컨텍스트가 단순하고 <code>refs</code>의 오버헤드를 쉽게 관리 할 수 있는 작은 기능으로 분리하는 경우가 더 많습니다.</li><li><code>refs</code>를 읽고 변경하는 것은 <code>.value</code>가 필요하기 때문에 일반값으로 작업하는 것보다 더 장황합니다. <br><br> 일부는 이것을 해결하기 위해 컴파일 타임 신텍스 슈거(Svelte 3와 유사)을 제안했습니다. 기술적으로 실현 가능하지만 Vue의 기본값으로 의미가 있다고 생각하지 않습니다(<a href="#svelte%EC%99%80-%EB%B9%84%EA%B5%90">Svelte와 비교</a>에서 논의 됨). 즉, 이것은 Userland에서 Babel 플러그인으로 기술적으로 가능합니다.</li></ol><p>우리는 Ref 개념을 완전히 피하고 반응성 객체만 사용할 수 있는지 여부에 대해 논의했습니다. 그러나:</p><ul><li>계산된 게터는 프리미티브 타입을 반환 할 수 있으므로 Ref와 유사한 컨테이너는 피할수 없습니다.</li><li>프리미티브 타입만 예상하거나 반환하는 컴포지션 함수는 반응성을 위해 객체의 값을 랩핑해야 합니다. 프레임워크에서 제공하는 표준 구현이 없는 경우 사용자는 자신만의 Ref와 유사한 패턴(그리고 에코시스템 파편화)을 개발하게 될 가능성이 큽니다.</li></ul><h3 id="ref-vs-reactive" tabindex="-1"><a class="header-anchor" href="#ref-vs-reactive" aria-hidden="true">#</a> Ref vs. Reactive</h3><p>당연히, 사용자는 <code>refs</code>과 <code>reactive</code> 사이에서 어느 것을 사용해야 할지 혼동 될 수 있습니다. 알아야 할 첫 번째 사항은 Composition API를 효율적으로 사용하려면 두 가지를 모두 이해해야한다는 것입니다. 하나를 독점적으로 사용하면 난해한 해결 방법이나 <a href="https://ko.wikipedia.org/wiki/%EB%B0%94%ED%80%B4%EC%9D%98_%EC%9E%AC%EB%B0%9C%EB%AA%85" target="_blank" rel="noopener noreferrer">바퀴의 재발명<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 될 가능성이 높습니다.</p><p><code>refs</code>와 <code>reactive</code>의 차이점은 표준 JavaScript 로직을 작성하는 방법과 다소 비교 될 수 있습니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 첫번째 스타일: 별도의 변수</span>
<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">function</span> <span class="token function">updatePosition</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  x <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX
  y <span class="token operator">=</span> e<span class="token punctuation">.</span>pageY
<span class="token punctuation">}</span>

<span class="token comment">// --- 비교해서 ---</span>

<span class="token comment">// 두번째 스타일: 단일 객체</span>
<span class="token keyword">const</span> pos <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">0</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">updatePosition</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  pos<span class="token punctuation">.</span>x <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX
  pos<span class="token punctuation">.</span>y <span class="token operator">=</span> e<span class="token punctuation">.</span>pageY
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>ref</code>를 사용한다면, 우리는 첫번째 스타일을 <code>refs</code>를 사용하여 보다 기본적으로 동등한 표현으로 변환하고 있습니다(원시값을 반응적으로 만들기 위해).</li><li>반응성을 사용하는 것은 두번째 스타일과 거의 동일합니다. 우리는 <code>reactive</code>로만 객체를 생성하면 됩니다.</li></ul><p>하지만 <code>reactive</code>만 사용하는 문제는 컴포지션 함수의 사용측에서 반응성을 유지하기 위해 항상 반환된 객체에 대한 참조를 유지해야 한다는 것입니다. 객체를 해체하거나 펼칠 수 없습니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 컴포지션 함수</span>
<span class="token keyword">function</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> pos <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// ...</span>
  <span class="token keyword">return</span> pos
<span class="token punctuation">}</span>

<span class="token comment">// 사용측 컴포넌트</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 반응성 손실됨!</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      x<span class="token punctuation">,</span>
      y
    <span class="token punctuation">}</span>

    <span class="token comment">// 반응성 손실됨!</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span><span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 이것이 반응성을 유지하는 유일한 방법입니다.</span>
    <span class="token comment">// pos를 있는 그대로 반환하고 x와 y를 pos.x와 pos.y로 탬플릿에서 참조해야 합니다.</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">pos</span><span class="token operator">:</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>이 제약 조건을 처리하기 위해 <code>toRefs</code> API가 제공됩니다. 반응형 객체의 각 속성을 해당 참조로 반환합니다.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> pos <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// ...</span>
  <span class="token keyword">return</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// x &amp; y are now refs!</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>요약하면 두 가지 실행 가능한 스타일이 있습니다.</p><ol><li>일반적인 JavaScript에서 프리미티브 타입 변수와 객체 변수를 선언하는 방식과 마찬가지로 <code>ref</code>와 <code>reactive</code>를 사용하십시오. 이 스타일을 사용할 때는 IDE를 지원하는 타입 시스템을 사용하는 것이 좋습니다.</li><li>가능하면 <code>reactive</code>를 사용하고 컴포지션 함수에서 반응형 객체를 반환할 때 <code>toRefs</code>를 사용해야합니다. 이렇게 하면 <code>refs</code>의 정신적인 오버헤드가 줄어들지만 개념에 익숙해질 필요는 없습니다.</li></ol><p>이 단계에서는 <code>refs</code>와 <code>reactive</code> 에 대한 모범 사례를 요구하기에는 너무 이르다고 생각합니다. 위의 두 가지 옵션 중에서 멘탈 모델에 더 잘 맞는 스타일을 사용하는 것이 좋습니다. 우리는 실제 사용자 피드백을 수집하고 결국이 주제에 대한 보다 명확한 지침을 제공 할 것입니다.</p><h3 id="반환문의-정확성" tabindex="-1"><a class="header-anchor" href="#반환문의-정확성" aria-hidden="true">#</a> 반환문의 정확성</h3><p>일부 사용자들은 <code>setup()</code> 의 반환문이 장황하고 보일럿 플레이트와 같은 느낌을 주는 것 아니냐는 우려를 제기하고 있습니다.</p><p>우리는 명시적인 반환문이 유지보수에 도움이 된다고 생각합니다. 이를 통해 템플릿에 노출되는 대상을 명시적으로 제어할 수 있으며 컴포넌트에서 템플릿 속성이 정의된 위치를 추적할 때 시작 시점으로 사용됩니다.</p><p><code>setup()</code> 에 선언된 변수를 자동으로 노출하여 반환문을 선택적으로 만들자는 제안이 있었습니다. 다시 말하지만, 이것이 표준 JavaScript의 직관에 어긋날 것이기 때문에 이것이 기본값이라고 생각하지 않습니다. 그러나 사용자 영역에서 덜 번거롭게 만드는 방법이 있습니다.</p><ul><li><code>setup()</code> 에 선언된 변수를 기반으로 반환문을 자동으로 생성하는 IDE 익스텐션</li><li>암시적으로 반환문을 생성하고 삽입하는 Babel 플러그인</li></ul><h3 id="유연성이-높을수록-더-많은-훈련이-필요합니다" tabindex="-1"><a class="header-anchor" href="#유연성이-높을수록-더-많은-훈련이-필요합니다" aria-hidden="true">#</a> 유연성이 높을수록 더 많은 훈련이 필요합니다</h3><p>많은 사용자들은 Composition API가 코드 구성에 더 많은 유연성을 제공하지만 개발자가 &quot;올바로&quot; 수행하는 데 더 많은 훈련이 필요하다고 지적했습니다. 일부는 API가 미숙한 손에 스파게티 코드로 이어질까 걱정합니다. 즉, Composition API는 코드 품질의 상한선을 높이는 동시에 하한선을 낮추기도 합니다.</p><p>우리는 어느 정도 동의합니다. 그러나 우리는 다음을 믿습니다:</p><ol><li>상한선의 이득이 하한선의 손실보다 큽니다.</li><li>적절한 문서 및 커뮤니티 지침을 통해 코드 구성 문제를 효과적으로 해결할 수 있습니다.</li></ol><p>일부 사용자는 <a href="https://docs.angularjs.org/guide/controller" target="_blank" rel="noopener noreferrer">Angular 1 컨트롤러<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>를 사용하여 설계에서 코드 작성이 잘못되는 방법을 예로 들었습니다. Composition API와 Angular 1 컨트롤러의 가장 큰 차이점은 공유 범위 컨텍스트에 의존하지 않는다는 것입니다. 따라서 JavaScript 코드 구성의 핵심 매커니즘인 논리를 별도의 함수로 훨씬 쉽게 분리 할 수 있습니다.</p><p>모든 JavaScript 프로그램은 엔트리 파일로 시작합니다(프로그램의 경우 <code>setup()</code> 이라고 생각하십시오). 논리적인 관심사에 따라 프로그램을 기능과 모듈로 분할하여 프로그램을 구성합니다. <strong>Composition API를 사용하면 Vue 컴포넌트 코드에 대해서도 동일한 작업을 수행 할 수 있습니다.</strong> 다시 말해, 잘 구성된 JavaScript 코드 작성 기술은 Composition API를 사용할 때 잘 구성된 Vue 코드 작성 기술로 직접 변환됩니다.</p><h2 id="적용-전략" tabindex="-1"><a class="header-anchor" href="#적용-전략" aria-hidden="true">#</a> 적용 전략</h2><p>Composition API는 순전히 부가적이며 기존 2.x API에 영향을 미치거나 어디에도 사용되지 않습니다. <code>@vue/composition</code> 라이브러리를 통해 2.x 플러그인으로 제공되었습니다. 라이브러리의 주요 목표는 API를 실험하고 피드백을 수집하는 방법을 제공하는 것입니다. 현재 구현은 이 제안으로 최신 상태이지만 플러그인이라는 기술적 제약으로 인해 약간의 불일치가 있을 수 있습니다. 이 제안이 업데이트 될 때 브레이크 체인지가 될 수 있으므로 이 단계에서는 프로덕션에서 사용하지 않는 것이 좋습니다.</p><p>우리는 API를 3.0에 내장하여 제공하려고 합니다. 기존 2.x 옵션과 함께 사용할 수 있습니다.</p><p>앱에서 Composition API를 독점적으로 사용하는 사용하는 경우 2.x 옵션에만 사용되는 코드를 삭제하고 라이브러리 크기를 줄이기 위해 컴파일 타임 플래그를 제공 할 수 있습니다. 그러나 이것은 완전히 선택사항입니다.</p><p>API는 해결해야 할 문제가 주로 대규모 응용 프로그램에 나타나기 때문에 고급 기능으로 자리를 잡을 것입니다. 설명서를 기본값으로 사용하기 위해 설명서를 정밀 검사하지는 않습니다. 대신 문서에 전용 섹션이 있습니다.</p><h2 id="부록" tabindex="-1"><a class="header-anchor" href="#부록" aria-hidden="true">#</a> 부록</h2><h3 id="클래스-api의-타입-이슈" tabindex="-1"><a class="header-anchor" href="#클래스-api의-타입-이슈" aria-hidden="true">#</a> 클래스 API의 타입 이슈</h3><p>클래스 API를 도입하는 주요 목표는 보다 나은 TypeScript 추론 지원과 함께 제공되는 대체 API를 제공하는 것이 었습니다. 그러나 Vue 구성 요소가 여러 소스에서 선언된 속성을 단일 <code>this</code> 컨텍스트로 병합해야한다는 사실은 클래스 기반 API에서도 약간의 문제를 일으킵니다.</p><p>props 입력이 그 예입니다. props을 <code>this</code> 에 병합하려면 컴포넌트 클래스에 제네릭 인자를 사용하거나 데코레이터를 사용해야합니다.</p><p>다음은 제네릭 인자를 사용하는 예입니다.</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Props</span> <span class="token punctuation">{</span>
  message<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component<span class="token operator">&lt;</span>Props<span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> props <span class="token operator">=</span> <span class="token punctuation">{</span>
    message<span class="token operator">:</span> String
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>제네릭 인자에 전달된 인터페이스는 type-land에만 있기 때문에 사용자는 여전히 <code>this</code> 에 대한 props 프록싱 동작에 대한 런타임 props 선언을 제공해야합니다. 이 이중 선언은 중복되고 어색합니다.</p><p>우리는 데코레이터를 대안으로 사용하는 것을 고려했습니다.</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component<span class="token operator">&lt;</span>Props<span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">prop</span></span> message<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>데코레이터를 사용하면 특히 TypeScript의 현재 구현이 TC39 제안과 완전히 일치하지 않을 때 많은 불확실성과 함께 2단계 사양에 의존합니다. 또한 <code>this.$props</code> 에서 데코레이터로 선언된 props 타입을 노출 할 수 있는 방법이 없으므로 TSX 지원이 중답됩니다. 사용자는 기술적으로 예상대로 작동하지 않을 때 <code>@prop message: string = &#39;foo&#39;</code> 로 prop의 기본값을 선언할 수 있다고 가정할 수 있습니다.</p><p>또한 현재 클래스 메소드의 인자에 컨텍스트 타이핑을 활용할 수 있는 방법이 없습니다. 즉, 클래스 <code>render</code> 함수에 전달된 인자는 클래스의 다른 특성을 기반으로 추론된 타입을 가질 수 없습니다.</p><h3 id="react-hooks과-비교" tabindex="-1"><a class="header-anchor" href="#react-hooks과-비교" aria-hidden="true">#</a> React Hooks과 비교</h3><p>함수 기반 API는 React Hooks와 동일한 수준의 논리 구성 기능을 제공하지만 몇 가지 중요한 차이점이 있습니다. React Hooks와 달리 <code>setup()</code> 함수는 한번만 호출됩니다. 이는 Vue의 Composition API를 사용하는 코드는 다음과 같습니다.</p><ul><li>일반적으로 관용적 JavaScript 코드의 직관과 더 잘 맞습니다.</li><li>호출 순서에 민감하지 않으며 조건부 일 수 있습니다.</li><li>각 렌더에서 반복적으로 호출되지 않으며 GC 압력이 적습니다.</li><li>인라인 핸들러가 자식 컴포넌트를 과도하게 다시 렌더링하는 것을 막기 위해 <code>useCallback</code> 이 거의 항상 필요한 문제는 아닙니다.</li><li>사용자가 올바른 의존성 배열을 전달하는 것을 잊어 버린 경우 <code>useEffect</code> 및 <code>useMemo</code> 가 오래된 변수를 캡처 할 수 있는 문제는 아닙니다. Vue의 자동 종속성 추적 기능은 감시자와 계산된 값이 항상 올바르게 무효화되도록 합니다.</li></ul><p>우리는 React Hooks의 창의성을 인정하며, 이 제안의 주요 영감원입니다. 그러나 위에서 언급한 문제는 설계에 존재하며 Vue의 반응성 모델이 그 주위에 방법을 제공한다는 것을 알았습니다.</p><h3 id="svelte와-비교" tabindex="-1"><a class="header-anchor" href="#svelte와-비교" aria-hidden="true">#</a> Svelte와 비교</h3><p>비록 매우 다른 노선을 선택했지만, Composition API와 Svelte 3의 컴파일러 기반 접근 방식은 실제로 개념적으로 상당히 공통적입니다. 단계별 예는 다음과 같습니다.</p><h4 id="vue" tabindex="-1"><a class="header-anchor" href="#vue" aria-hidden="true">#</a> Vue</h4><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> watchEffect<span class="token punctuation">,</span> onMounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

    <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      count<span class="token punctuation">.</span>value<span class="token operator">++</span>
    <span class="token punctuation">}</span>

    <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;mounted!&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      count<span class="token punctuation">,</span>
      increment
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="svelte" tabindex="-1"><a class="header-anchor" href="#svelte" aria-hidden="true">#</a> Svelte</h4><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> <span class="token punctuation">{</span> onMount <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;svelte&#39;</span>

<span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  count<span class="token operator">++</span>
<span class="token punctuation">}</span>

<span class="token literal-property property">$</span><span class="token operator">:</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>

<span class="token function">onMount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;mounted!&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Svelte 코드는 컴파일 타임에 다음을 수행하기 때문에 더 간결해 보입니다.</p><ul><li>전체 <code>&lt;script&gt;</code> 블록 (import 문 제외)을 한번만 실행하는 대신 각 컴포넌트 인스턴스에 대해 호출되는 함수로 암시적으로 래핑합니다.</li><li>가변 뮤테이션에 대한 반응성을 암시적으로 등록</li><li>모든 범위 내 변수를 렌더 컨텍스트에 암시적으로 노출</li><li><code>$</code> 문을 재실행된 코드로 컴파일</li></ul><p>기술적으로 Vue에서 동일한 작업을 수행할 수 있습니다 (userland Babel 플러그인을 통해 가능). 우리가 하지 않는 주된 이유는 <strong>표준 JavaScript에 대한 지지</strong> 입니다. Vue 파일의 <code>&lt;script&gt;</code> 블록에서 코드를 추출하면 표준 ES 모듈과 동일하게 작동하기를 원합니다. 반면 Svelte <code>&lt;script&gt;</code> 블록 안의 코드는 기술적으로 더 이상 표준 JavaScript가 아닙니다. 이 컴파일러 기반 접근 방식에는 여러 가지 문제점이 있습니다.</p><ol><li>코드는 컴파일과 함께 / 컴파일 없이 다르게 작동합니다. 프로그레시브 프레임워크로서, 많은 Vue 사용자는 빌드 설정없이 사용하기를 원하거나 필요로 할 수 있으므로 컴파일된 버전이 기본값이 될 수 없습니다. 반면 Svelte는 자신을 컴파일러로 지정하고 빌드 단계와 함께만 사용할 수 있습니다. 이것이 두 프레임워크가 의식적으로 만들도 있는 트레이드 오프입니다.</li><li>코드는 컴포넌트 내부 / 외부에서 다르게 작동합니다. Svelte 컴포넌트에서 표준 JavaScript 파일로 조식을 추출하려고 할 때, 우리는 마법의 간결한 구문을 읽고 <a href="https://svelte.dev/docs#svelte_store" target="_blank" rel="noopener noreferrer">더 자세한 저수준 API<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 로 돌아 가야합니다.</li><li>Svelte의 반응형 컴파일은 최상위 변수에 대해서만 작동합니다. 함수 내에 선언된 변수를 건드리지 않으므로 <a href="https://svelte.dev/repl/4b000d682c0548e79697ddffaeb757a3?version=3.6.2" target="_blank" rel="noopener noreferrer">컴포넌트 내에 선언된 함수에서 반응 상태를 캡슐화 할 수 없습니다<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>. 이 기능은 코드 구성에 사소한 제약 조건을 부여합니다. 이 RFC에서 설명했듯이 큰 컴포넌트를 유지 관리하는 데 중요합니다.</li><li><a href="https://github.com/sveltejs/svelte/issues/1639" target="_blank" rel="noopener noreferrer">비표준 문법은 TypeScript와의 통합에 문제가 있습니다<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>.</li></ol><p>이것은 Svelte 3가 나쁜 생각이라고 결코 말하지 않습니다. 사실 이것은 매우 혁신적인 접근 방식이며 Rich의 작업을 매우 존중합니다. 그러나 Vue의 설계 제약과 목표에 따라 다른 트레이드 오프를 만들어야 합니다.</p></div><!----><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">마지막 수정: </span><!----></div><!----></div></footer><nav class="vp-page-nav"><!----><a class="vp-link nav-link next" href="/fe-dev/framework/composition-api-rfc-summary.html"><div class="hint">다음<span class="arrow end"></span></div><div class="link">Composition API RFC 요약 및 자료 정리<!----></div></a></nav><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-296313bb.js" defer></script>
  </body>
</html>
